<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Learning Study Plan</title>
    <style>
        body { font-family: sans-serif; line-height: 1.6; margin: 20px; }
        h1 { color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; }
        h2 { color: #34495e; margin-top: 30px; border-bottom: 1px solid #95a5a6; padding-bottom: 5px;}
        h3 { color: #7f8c8d; margin-top: 20px; }
        p { margin-bottom: 10px; }
        pre { background-color: #ecf0f1; padding: 15px; border-radius: 5px; overflow-x: auto; white-space: pre-wrap; }
        /* Original code style was just: code { font-family: monospace; } */
        /* New global code style */
        code {
            background-color: #eef1f3; /* A light, neutral gray */
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
            font-size: 0.9em;
            padding: 3px 6px;
            border-radius: 5px;
            border: 1px solid #dce2e6;
        }
        /* Ensure preformatted code blocks are not negatively affected by global code style */
        pre code {
            background-color: transparent; /* Revert background for pre code */
            font-family: monospace; /* Keep monospace for pre code */
            font-size: 1em; /* Revert font size for pre code */
            padding: 0; /* Revert padding for pre code */
            border-radius: 0; /* Revert border-radius for pre code */
            border: none; /* Revert border for pre code */
        }
        .page-break { page-break-after: always; }

        /* Table styles */
        table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 20px;
            border: 1px solid #ddd;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
            vertical-align: top;
        }
        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        caption {
            caption-side: top;
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: left;
        }

        /* List item styles */
        ul > li {
            margin-bottom: 8px; /* Creates visual separation */
        }
        /* Add some margin to nested lists as well for clarity */
        ul ul, ul ol, ol ul, ol ol {
            margin-top: 5px;
            margin-bottom: 5px;
        }
        ol > li {
            margin-bottom: 8px; /* Creates visual separation */
        }

        /* Syntax Highlighting Styles */
        .code-keyword { color: #0077aa; font-weight: bold; } /* Blue, bold for keywords */
        .code-string { color: #009933; } /* Green for strings */
        .code-comment { color: #999999; font-style: italic; } /* Gray, italic for comments */
        .code-function { color: #DC322F; } /* Red for functions */
        .code-class { color: #B58900; } /* Yellow/Brown for classes */
        .code-number { color: #D33682; } /* Magenta for numbers */
        .code-operator { color: #6C71C4; } /* Violet for operators */
        .code-builtin { color: #2AA198; } /* Cyan for built-ins */
    </style>
</head>
<body>
    <h1>Python Learning Study Plan</h1>
    <p><em>Extracted from PDF</em></p>

    <h2>Introduction</h2>
    <p>Python has emerged as a dominant force in the programming landscape, valued for its
readability, versatility, and extensive ecosystem of libraries. This study plan provides a
structured approach to learning Python, progressing from fundamental concepts to more
advanced topics. Each module is designed to build upon the previous, fostering a
comprehensive understanding of the language and its capabilities. The plan incorporates key
areas of Python programming, including basic syntax, control flow, functions, data structures,
object-oriented principles, file handling, error management, and modern Pythonic constructs,
culminating in guidance for continued learning and practice.</p>

    <h2>Module 1: Python Fundamentals – The Building Blocks</h2>
    <p>This initial module establishes the foundational knowledge required to begin programming in
Python. It covers the core characteristics of the language, the setup process, basic syntax,
fundamental data types, and the operators used to manipulate them.</p>

    <h3>1.1. Introduction to Python: What and Why?</h3>
    <p>Python is a high-level, interpreted programming language renowned for its clear syntax and
readability, often described as "executable pseudocode". Created by Guido van Rossum and
first released in 1991, its design philosophy emphasizes code readability and a syntax that
allows programmers to express concepts in fewer lines of code than might be possible in
languages like C++ or Java. Python supports multiple programming paradigms, including
procedural, object-oriented, and functional programming.
Its versatility makes it suitable for a wide array of applications, including web development,
data science, artificial intelligence, machine learning, scientific computing, automation, and
more. The language's extensive standard library and a vast collection of third-party
packages, accessible via the Python Package Index (PyPI), significantly extend its
capabilities. Python's large and active community contributes to its rich ecosystem and
provides ample resources for learners.
The design of Python, particularly its straightforward syntax and dynamic typing system,
contributes significantly to a reduced initial learning curve for aspiring programmers. This
accessibility allows beginners to concentrate more on understanding programming logic and
problem-solving rather than becoming entangled in complex syntactic requirements, which
often creates a more positive and encouraging learning trajectory. This characteristic is a
strong factor in Python's widespread adoption in educational settings and by individuals
pursuing self-directed learning.</p>
    <div class="page-break"></div>
    <h3>1.2. Setting Up and First Steps: Installation, Basic Syntax, Variables</h3>
    <p>Getting started with Python involves installing the interpreter from the official website,
python.org, which provides installers for various operating systems like Windows, macOS, and
Linux. Many Linux and UNIX distributions, and even some Windows computers, come with
Python pre-installed.
Once installed, one can start writing Python code. A basic "Hello, World!" program, a
traditional first step in learning a new language, can be written with a simple <code>print()</code> statement
:</p>
<pre><code><span class="code-builtin">print</span>(<span class="code-string">"Hello, I'm Python!"</span>)</code></pre>
    <p>Python's syntax is designed to be clean and readable. It uses indentation to define code
blocks (e.g., within functions or control flow statements), rather than braces or keywords,
which is a distinctive feature. Comments are used to explain code; single-line comments begin
with a hash symbol (#), and multi-line comments can be achieved using multiple hash
symbols or by using multi-line strings (docstrings), although the latter are primarily intended
for documentation.
Variables in Python are used to store data. A key feature of Python is its dynamic typing
system, meaning one does not need to explicitly declare the data type of a variable; Python
infers it at runtime. Assignment is done using the equals sign (=). For example:</p>
<pre><code>name <span class="code-operator">=</span> <span class="code-builtin">input</span>(<span class="code-string">'What is your name?\n'</span>) <span class="code-comment"># Takes user input and assigns it to 'name'</span>
<span class="code-builtin">print</span>(f<span class="code-string">'Hi, {name}.'</span>) <span class="code-comment"># Uses an f-string for formatted output</span></code></pre>
    <p>This example also demonstrates taking user input using the <code>input()</code> function and formatted
string literals (f-strings) for output.</p>

    <h3>1.3. Core Data Types: Numbers (int, float, complex), Strings, Booleans</h3>
    <p>Python supports several built-in data types that are fundamental for programming. These
types are, in fact, classes, and variables are instances (objects) of these classes.
Understanding these types is crucial for effective data manipulation.
Numeric Types:</p>
    <p>Python offers three distinct numeric types:</p>
    <ul>
<li>Integers (<code>int</code>): These represent whole numbers, both positive and negative, without a
fractional component. Python integers have arbitrary precision, meaning they can be as
large as available memory allows. Example: age = 25.</li>
<li>Floating-point numbers (<code>float</code>): These represent numbers with a decimal point or in
exponential form. They are used for values requiring fractional precision, such as
measurements or financial calculations. Floats in Python are typically implemented as
IEEE 754 double-precision numbers, offering accuracy up to about 15-17 decimal
places. Example: price = 19.99.</li>
<li>Complex numbers (<code>complex</code>): These represent numbers with a real and an imaginary
part, written as a + bj, where a is the real part and b is the imaginary part. They are
useful in scientific and engineering domains. Example: z = 2 + 3j.</li>
    </ul>
    <p>The built-in <code>type()</code> function can be used to determine the data type of a variable or value. For
instance, <code>type(age)</code> would return &lt;class '<code>int</code>'&gt;.
Strings (<code>str</code>):
Strings are ordered, immutable sequences of Unicode characters, used to represent textual
data. They can be enclosed in single quotes ('...') or double quotes ("..."). Multi-line strings
can be created using triple quotes ("""...""" or '''...'''). Since strings are immutable, operations
that appear to modify a string actually create a new string object. Basic operations include
concatenation (+) and repetition (*). Example: greeting = "Hello, Python!".
Booleans (<code>bool</code>):
The Boolean type has two possible values: <code>True</code> and <code>False</code>. These are used to represent truth
values and are fundamental to conditional logic and control flow statements. Boolean values
are often the result of comparison operations. Example: is_active = True.
The way these fundamental data types are introduced in many learning resources, often with
immediate, practical examples (e.g., age = 25 for integers, price = 19.99 for floats), helps
learners connect abstract concepts to tangible applications from the very beginning. This
approach of contextualizing data types makes them less abstract and facilitates a
learning-by-doing methodology.
The following table provides a consolidated summary of these core data types:</p>
    <table>
      <caption>Table 1: Python Core Data Types Quick Reference</caption>
      <thead>
        <tr>
          <th>Data Type</th>
          <th>Description</th>
          <th>Mutability</th>
          <th>Python Class</th>
          <th>Example Syntax</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Integer</td>
          <td>Whole numbers (positive, negative, zero)</td>
          <td>Immutable</td>
          <td><code>int</code></td>
          <td>x = 10, y = -5</td>
        </tr>
        <tr>
          <td>Floating-Point</td>
          <td>Numbers with a decimal point or exponent</td>
          <td>Immutable</td>
          <td><code>float</code></td>
          <td>pi = 3.14, val = 2.5e4</td>
        </tr>
        <tr>
          <td>Complex</td>
          <td>Numbers with real and imaginary parts (a+bj)</td>
          <td>Immutable</td>
          <td><code>complex</code></td>
          <td>c = 1 + 2j</td>
        </tr>
        <tr>
          <td>String</td>
          <td>Ordered sequence of Unicode characters</td>
          <td>Immutable</td>
          <td><code>str</code></td>
          <td>s = "hello", s = 'hi'</td>
        </tr>
        <tr>
          <td>Boolean</td>
          <td>Logical truth values (True or False)</td>
          <td>Immutable</td>
          <td><code>bool</code></td>
          <td>is_valid = True</td>
        </tr>
      </tbody>
    </table>
    <p>Data Sources:</p>

    <h3>1.4. Python Operators: Arithmetic, Assignment, Comparison, Logical,
Bitwise, Special</h3>
    <p>Operators are special symbols in Python that carry out operations on operands (values or
variables). Python supports a rich set of operators.</p>
    <ul>
        <li>Arithmetic Operators: Used for mathematical calculations.
            <ul>
                <li><code>+</code> (addition), <code>-</code> (subtraction), <code>*</code> (multiplication)</li>
                <li><code>/</code> (division - always results in a <code>float</code>)</li>
                <li><code>//</code> (floor division - results in an <code>int</code>, discards remainder)</li>
                <li><code>%</code> (modulo - returns the remainder of a division)</li>
                <li><code>**</code> (exponentiation - raises to the power)</li>
                <li>Examples: 17 <code>/</code> 3 results in 5.666..., while 17 <code>//</code> 3 results in 5.</li>
            </ul>
        </li>
        <li>Assignment Operators: Used to assign values to variables.
            <ul>
                <li><code>=</code> (assign)</li>
                <li><code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>//=</code>, <code>%=</code>, <code>**=</code> (compound assignment, e.g., x <code>+=</code> 5 is x <code>=</code> x <code>+</code> 5)</li>
                <li></li>
            </ul>
        </li>
        <li>Comparison Operators: Used to compare two values; they return <code>True</code> or <code>False</code>.
            <ul>
                <li><code>==</code> (equal to), <code>!=</code> (not equal to)</li>
                <li><code>&gt;</code> (greater than), <code>&lt;</code> (less than)</li>
                <li><code>&gt;=</code> (greater than or equal to), <code>&lt;=</code> (less than or equal to)</li>
                <li></li>
            </ul>
        </li>
        <li>Logical Operators: Used to combine conditional statements; they operate on Boolean
values.
            <ul>
                <li><code>and</code> (returns <code>True</code> if both operands are true)</li>
                <li><code>or</code> (returns <code>True</code> if at least one operand is true)</li>
                <li><code>not</code> (returns <code>True</code> if the operand is false, and vice-versa)</li>
                <li></li>
            </ul>
        </li>
        <li>Bitwise Operators: Perform operations on integers at the binary level. These are less
commonly used by beginners but are important for certain low-level manipulations.
            <ul>
                <li><code>&amp;</code> (bitwise AND), <code>|</code> (bitwise OR), <code>~</code> (bitwise NOT)</li>
                <li><code>^</code> (bitwise XOR), <code>&gt;&gt;</code> (bitwise right shift), <code>&lt;&lt;</code> (bitwise left shift)</li>
                <li></li>
            </ul>
        </li>
        <li>Special Operators:
            <ul>
                <li>Identity Operators: <code>is</code>, <code>is not</code>. These check if two operands refer to the exact
same object in memory, not just if they are equal in value.</li>
                <li>Membership Operators: <code>in</code>, <code>not in</code>. These test whether a value is present in a
sequence (like a <code>list</code>, <code>tuple</code>, or <code>string</code>) or a key is present in a <code>dictionary</code>.</li>
            </ul>
        </li>
    </ul>
    <p>Understanding operator precedence (the order in which operations are performed) is also
important, though parentheses <code>()</code> can always be used to explicitly control the order of
evaluation.
The learning focus for this module is to achieve a solid grasp of Python's fundamental syntax
and the basic mechanisms for data manipulation. These elements form the essential bedrock
upon which all subsequent Python programming knowledge will be constructed.</p>

    <h2>Module 2: Controlling the Flow of Your Code</h2>
    <p>Program execution often needs to vary based on certain conditions or repeat blocks of code.
This module explores Python's control flow statements, which are essential for creating
dynamic and logical programs. The ability to direct program execution based on conditions
and repetition is fundamental to developing algorithms and solving problems with code.</p>

    <h3>2.1. Conditional Logic: if, elif, else Statements</h3>
    <p>Conditional statements allow a program to execute specific blocks of code depending on
whether certain conditions evaluate to <code>True</code> or <code>False</code>.</p>
    <ul>
        <li>The <code>if</code> statement is the most basic conditional statement. Its associated block of code
executes only if the specified condition is <code>True</code>.​
<pre><code>x <span class="code-operator">=</span> <span class="code-number">10</span>
<span class="code-keyword">if</span> x <span class="code-operator">&gt;</span> <span class="code-number">5</span>:
    <span class="code-builtin">print</span>(<span class="code-string">"x is greater than 5"</span>) <span class="code-comment"># This will be printed</span></code></pre>
        </li>
        <li>The <code>else</code> statement can be used in conjunction with an <code>if</code> statement to provide an
alternative block of code that executes if the <code>if</code> condition is <code>False</code>.​
<pre><code>age <span class="code-operator">=</span> <span class="code-number">15</span>
<span class="code-keyword">if</span> age <span class="code-operator">&gt;=</span> <span class="code-number">18</span>:
    <span class="code-builtin">print</span>(<span class="code-string">"Adult"</span>)
<span class="code-keyword">else</span>:
    <span class="code-builtin">print</span>(<span class="code-string">"Minor"</span>) <span class="code-comment"># This will be printed</span></code></pre>
        </li>
        <li>The <code>elif</code> (else if) statement allows for checking multiple conditions sequentially. If an <code>if</code>
condition is <code>False</code>, the program checks the <code>elif</code> conditions one by one. The code block
associated with the first <code>elif</code> condition that evaluates to <code>True</code> is executed. An optional
<code>else</code> block can follow the <code>elif</code> statements to handle cases where none of the <code>if</code> or <code>elif</code>
conditions are met.​</li>
    </ul>
<pre><code>score <span class="code-operator">=</span> <span class="code-number">85</span>
<span class="code-keyword">if</span> score <span class="code-operator">&gt;=</span> <span class="code-number">90</span>:
    <span class="code-builtin">print</span>(<span class="code-string">"Grade A"</span>)</code></pre>
    <div class="page-break"></div>
<pre><code><span class="code-keyword">elif</span> score <span class="code-operator">&gt;=</span> <span class="code-number">80</span>:
    <span class="code-builtin">print</span>(<span class="code-string">"Grade B"</span>) <span class="code-comment"># This will be printed</span>
<span class="code-keyword">elif</span> score <span class="code-operator">&gt;=</span> <span class="code-number">70</span>:
    <span class="code-builtin">print</span>(<span class="code-string">"Grade C"</span>)
<span class="code-keyword">else</span>:
    <span class="code-builtin">print</span>(<span class="code-string">"Grade D"</span>)</code></pre>
    <p>Conditional statements can also be nested, meaning an <code>if</code>, <code>elif</code>, or <code>else</code> block can contain
another set of conditional statements, allowing for more complex decision-making logic. The
conditions themselves are typically Boolean expressions, often involving comparison and
logical operators.
The capacity to make decisions using <code>if</code>, <code>elif</code>, and <code>else</code> statements, combined with the ability to
repeat actions through loops, forms the core of nearly all non-trivial programs. Thus,
mastering these control flow mechanisms is not merely about learning Python syntax but
about developing the foundational skills for algorithmic thinking, which are transferable
across various programming languages.</p>

    <h3>2.2. Iteration with Loops: for and while</h3>
    <p>Loops are used to execute a block of code repeatedly. Python provides two main types of
loops: <code>for</code> loops and <code>while</code> loops.
<code>for</code> Loops:
<code>for</code> loops are primarily used to iterate over the items of any sequence (such as a <code>list</code>, <code>tuple</code>, or
<code>string</code>) or other iterable objects, in the order that they appear in the sequence.</p>
<pre><code>fruits <span class="code-operator">=</span> [<span class="code-string">"apple"</span>, <span class="code-string">"banana"</span>, <span class="code-string">"cherry"</span>]
<span class="code-keyword">for</span> fruit <span class="code-keyword">in</span> fruits:
    <span class="code-builtin">print</span>(fruit)</code></pre>
    <p>The <code>range()</code> function is commonly used with <code>for</code> loops to generate a sequence of numbers,
which is useful when one needs to iterate a specific number of times or create numeric
sequences.</p>
<pre><code><span class="code-keyword">for</span> i <span class="code-keyword">in</span> <span class="code-builtin">range</span>(<span class="code-number">5</span>): <span class="code-comment"># Generates numbers from 0 to 4</span>
    <span class="code-builtin">print</span>(i)</code></pre>
    <p>The variable used in the loop (e.g., fruit or i above) takes on the value of the current item in
the sequence during each iteration.
<code>while</code> Loops:
<code>while</code> loops repeat a block of code as long as a specified Boolean condition remains <code>True</code>.</p>
<pre><code>count <span class="code-operator">=</span> <span class="code-number">0</span>
<span class="code-keyword">while</span> count <span class="code-operator">&lt;</span> <span class="code-number">3</span>:
    <span class="code-builtin">print</span>(f<span class="code-string">"Count is {count}"</span>)
    count <span class="code-operator">+=</span> <span class="code-number">1</span> <span class="code-comment"># Crucial to update the loop variable</span></code></pre>
    <p>It is essential to ensure that the condition of a <code>while</code> loop eventually becomes <code>False</code>; otherwise,
it will result in an infinite loop. This usually involves updating a variable within the loop body
that affects the loop's condition.
Both <code>for</code> and <code>while</code> loops can be nested, meaning one loop can be placed inside another,
which is useful for tasks like iterating over multi-dimensional data structures.
A unique feature in Python is the <code>else</code> clause in loops. For both <code>for</code> and <code>while</code> loops, an <code>else</code>
block can be added. This block is executed if the loop completes its iterations normally (i.e., it
was not terminated by a <code>break</code> statement). This construct can be particularly useful for
search operations, where the <code>else</code> block might handle the "item not found" scenario.</p>
<pre><code>numbers <span class="code-operator">=</span> [<span class="code-number">1</span>, <span class="code-number">3</span>, <span class="code-number">5</span>, <span class="code-number">7</span>]
<span class="code-keyword">for</span> num <span class="code-keyword">in</span> numbers:
    <span class="code-keyword">if</span> num <span class="code-operator">%</span> <span class="code-number">2</span> <span class="code-operator">==</span> <span class="code-number">0</span>:
        <span class="code-builtin">print</span>(f<span class="code-string">"Even number found: {num}"</span>)
        <span class="code-keyword">break</span>
<span class="code-keyword">else</span>: <span class="code-comment"># Executed if the loop completes without a 'break'</span>
    <span class="code-builtin">print</span>(<span class="code-string">"No even numbers found."</span>)</code></pre>
    <p>This Pythonic feature often leads to clearer and more readable code compared to using flag
variables to track whether a loop was exited prematurely.</p>

    <h3>2.3. Modifying Loop Behavior: break and continue</h3>
    <p>Python provides two statements, <code>break</code> and <code>continue</code>, to alter the standard flow of loops.</p>
    <ul>
        <li>The <code>break</code> statement is used to exit a loop immediately, regardless of the loop's
condition or remaining items in the sequence. Execution continues with the first
statement after the loop. It is commonly used when a specific condition is met and
further iteration is unnecessary, such as finding an item in a search.​
    <div class="page-break"></div>
<pre><code><span class="code-keyword">for</span> number <span class="code-keyword">in</span> <span class="code-builtin">range</span>(<span class="code-number">1</span>, <span class="code-number">10</span>):
    <span class="code-keyword">if</span> number <span class="code-operator">==</span> <span class="code-number">5</span>:
        <span class="code-keyword">break</span> <span class="code-comment"># Loop terminates when number is 5</span>
    <span class="code-builtin">print</span>(number) <span class="code-comment"># Prints 1, 2, 3, 4</span></code></pre>
        </li>
        <li>The <code>continue</code> statement is used to skip the rest of the code inside the current iteration
of the loop and proceed directly to the next iteration. It is useful when one wants to
bypass processing for certain elements that meet a specific criterion but continue with
the loop for other elements.​
<pre><code><span class="code-keyword">for</span> number <span class="code-keyword">in</span> <span class="code-builtin">range</span>(<span class="code-number">1</span>, <span class="code-number">6</span>):
    <span class="code-keyword">if</span> number <span class="code-operator">==</span> <span class="code-number">3</span>:
        <span class="code-keyword">continue</span> <span class="code-comment"># Skips printing 3</span>
    <span class="code-builtin">print</span>(number) <span class="code-comment"># Prints 1, 2, 4, 5</span></code></pre>
    <p>While loops can function without <code>break</code> and <code>continue</code>, these statements provide more refined
control over loop execution. They often lead to more elegant and efficient solutions by
avoiding the need for complex nested conditional statements or the use of additional flag
variables to manage loop state. This contributes to cleaner and more readable loop
structures.
The learning focus for this module is on mastering how to direct program execution based on
conditions and how to perform repetitive tasks efficiently using loops. These control flow
structures are fundamental to creating programs that can perform complex and dynamic
operations.</p>

    <h2>Module 3: Organizing Code with Functions</h2>
    <p>Functions are a fundamental concept in programming, allowing for the encapsulation of a
block of code that performs a specific task. This module covers defining and using functions,
understanding how arguments are passed, how values are returned, and the concept of
variable scope. Functions are pivotal for writing modular, reusable, and maintainable code,
preventing repetition and making complex programs easier to manage.</p>

    <h3>3.1. Defining and Calling Functions</h3>
    <p>A function is a named sequence of statements that performs a computation. Functions help in
breaking down a program into smaller, manageable chunks.
Syntax for Defining a Function:
In Python, functions are defined using the <code>def</code> keyword, followed by the function name,
parentheses <code>()</code> which may enclose parameters, and a colon :. The body of the function is
indented.</p>
<pre><code></code></pre>
    <div class="page-break"></div>
<pre><code><span class="code-keyword">def</span> <span class="code-function">greet</span>(): <span class="code-comment"># A simple function without parameters</span>
    <span class="code-builtin">print</span>(<span class="code-string">"Hello, Python learner!"</span>)</code></pre>
    <p>Calling a Function:
To execute a function, one calls it by its name followed by parentheses. If the function expects
arguments, they are passed within the parentheses.</p>
<pre><code><span class="code-function">greet</span>() <span class="code-comment"># Calls the function defined above</span></code></pre>
    <p>Docstrings:
It is a good practice to include a docstring (documentation string) as the first statement in a
function's body. Docstrings are enclosed in triple quotes ("""...""" or '''...''') and explain what
the function does, its parameters, and what it returns. They are accessible via the <code>help()</code>
function or the <code>__doc__</code> attribute and are crucial for code documentation and
maintainability.</p>
<pre><code><span class="code-keyword">def</span> <span class="code-function">add_numbers</span>(a, b):
    <span class="code-string">"""
    Adds two numbers and returns the sum.

    Parameters:
    a (int or float): The first number.
    b (int or float): The second number.

    Returns:
    int or float: The sum of a and b.
    """</span>
    <span class="code-keyword">return</span> a <span class="code-operator">+</span> b</code></pre>
    <h3>3.2. Understanding Function Arguments: Positional, Keyword, Default,
Arbitrary (<code>*args</code>, <code>**kwargs</code>)</h3>
    <p>Python offers flexible ways to pass arguments to functions, enhancing their versatility.</p>
    <ul>
        <li>Positional Arguments: These are the most common type. Arguments are passed to the
function in the order they are defined in the function's parameter list. The number of
arguments in the call must match the number of parameters.​
<pre><code><span class="code-keyword">def</span> <span class="code-function">describe_pet</span>(animal_type, pet_name):
    <span class="code-builtin">print</span>(f<span class="code-string">"I have a {animal_type} named {pet_name}."</span>)

<span class="code-function">describe_pet</span>(<span class="code-string">"hamster"</span>, <span class="code-string">"Harry"</span>) <span class="code-comment"># "hamster" is animal_type, "Harry" is pet_name</span></code></pre>
        </li>
        <li>Keyword Arguments: Arguments can be passed using the name=value syntax. This
allows arguments to be passed out of order because Python matches them based on
the parameter name.​
<pre><code><span class="code-function">describe_pet</span>(pet_name<span class="code-operator">=</span><span class="code-string">"Lucy"</span>, animal_type<span class="code-operator">=</span><span class="code-string">"dog"</span>)</code></pre>
        </li>
        <li>Default Argument Values: Parameters can be assigned default values in the function
definition. If an argument for that parameter is not provided during the function call, the
default value is used, making the argument optional.​
<pre><code><span class="code-keyword">def</span> <span class="code-function">greet_user</span>(name, greeting<span class="code-operator">=</span><span class="code-string">"Hello"</span>): <span class="code-comment"># greeting has a default value</span>
    <span class="code-builtin">print</span>(f<span class="code-string">"{greeting}, {name}!"</span>)

<span class="code-function">greet_user</span>(<span class="code-string">"Alice"</span>) <span class="code-comment"># Uses default greeting: "Hello, Alice!"</span>
<span class="code-function">greet_user</span>(<span class="code-string">"Bob"</span>, <span class="code-string">"Hi"</span>) <span class="code-comment"># Overrides default: "Hi, Bob!"</span></code></pre>
            <p>A common pitfall is using mutable objects (like <code>lists</code> or <code>dictionaries</code>) as default
arguments. The default value is evaluated only once when the function is defined, not
each time it's called. This can lead to unexpected behavior if the mutable default is
modified in one call, as the change will persist for subsequent calls. A common
workaround is to use <code>None</code> as the default and create the mutable object inside the
function if needed.</p>
        </li>
        <li>Arbitrary Positional Arguments (<code>*args</code>): A function can accept a variable number of
positional arguments by prefixing a parameter name with an asterisk (<code>*</code>). These
arguments are collected into a <code>tuple</code> within the function.​
<pre><code><span class="code-keyword">def</span> <span class="code-function">print_all_items</span>(<span class="code-operator">*</span>items): <span class="code-comment"># items will be a tuple</span>
    <span class="code-keyword">for</span> item <span class="code-keyword">in</span> items:
        <span class="code-builtin">print</span>(item)

<span class="code-function">print_all_items</span>(<span class="code-string">"apple"</span>, <span class="code-string">"banana"</span>, <span class="code-string">"cherry"</span>)</code></pre>
        </li>
        <li>Arbitrary Keyword Arguments (<code>**kwargs</code>): A function can accept a variable number
of keyword arguments by prefixing a parameter name with double asterisks (<code>**</code>). These
arguments are collected into a <code>dictionary</code> within the function.​</li>
    </ul>
    <div class="page-break"></div>
<pre><code><span class="code-keyword">def</span> <span class="code-function">print_user_info</span>(<span class="code-operator">**</span>info): <span class="code-comment"># info will be a dictionary</span>
    <span class="code-keyword">for</span> key, value <span class="code-keyword">in</span> info.items():
        <span class="code-builtin">print</span>(f<span class="code-string">"{key}: {value}"</span>)

<span class="code-function">print_user_info</span>(name<span class="code-operator">=</span><span class="code-string">"John Doe"</span>, age<span class="code-operator">=</span><span class="code-number">30</span>, city<span class="code-operator">=</span><span class="code-string">"New York"</span>)</code></pre>
    <p>The standard order for parameters in a function definition is: standard positional arguments,
then <code>*args</code>, then default arguments (or keyword-only arguments), and finally <code>**kwargs</code>. This
flexibility in argument passing allows developers to design functions that can accommodate a
wide range of calling patterns, contributing to Python's adaptability and conciseness without
needing multiple overloaded function definitions as seen in some other languages.</p>

    <h3>3.3. The return Statement: Getting Values from Functions</h3>
    <p>The <code>return</code> statement is used to exit a function and send a value (or values) back to the part of
the code that called the function (the caller).</p>
    <ul>
        <li>A function can return any Python object, including numbers, strings, <code>lists</code>, <code>dictionaries</code>,
or even other functions.</li>
        <li>If a function does not have an explicit <code>return</code> statement, or if <code>return</code> is used without an
expression, the function implicitly returns <code>None</code>.​
<pre><code><span class="code-keyword">def</span> <span class="code-function">get_square</span>(number):
    <span class="code-keyword">return</span> number <span class="code-operator">*</span> number

result <span class="code-operator">=</span> <span class="code-function">get_square</span>(<span class="code-number">5</span>) <span class="code-comment"># result will be 25</span>
<span class="code-builtin">print</span>(result)

<span class="code-keyword">def</span> <span class="code-function">simple_print</span>(message):
    <span class="code-builtin">print</span>(message) <span class="code-comment"># No explicit return</span>

output <span class="code-operator">=</span> <span class="code-function">simple_print</span>(<span class="code-string">"Test"</span>) <span class="code-comment"># output will be None</span>
<span class="code-builtin">print</span>(output)</code></pre>
        </li>
        <li>To return multiple values from a function, one can list them after the <code>return</code> keyword,
separated by commas. Python automatically packs these values into a <code>tuple</code>.​</li>
    </ul>
<pre><code><span class="code-keyword">def</span> <span class="code-function">get_coordinates</span>():
    <span class="code-keyword">return</span> <span class="code-number">10</span>, <span class="code-number">20</span> <span class="code-comment"># Returns a tuple (10, 20)</span>

x, y <span class="code-operator">=</span> <span class="code-function">get_coordinates</span>() <span class="code-comment"># Tuple unpacking</span>
<span class="code-builtin">print</span>(f<span class="code-string">"X: {x}, Y: {y}"</span>)</code></pre>
    <div class="page-break"></div>
    <h3>3.4. Variable Scope: Local, Global, and Nonlocal</h3>
    <p>Variable scope refers to the region of a program where a variable is accessible. Understanding
scope is crucial for avoiding naming conflicts and unintended variable modifications.</p>
    <ul>
        <li>Local Scope: Variables defined inside a function are local to that function. They are
created when the function is called and destroyed when the function exits. They cannot
be accessed from outside the function.​
<pre><code><span class="code-keyword">def</span> <span class="code-function">my_function</span>():
    local_var <span class="code-operator">=</span> <span class="code-number">100</span> <span class="code-comment"># local_var is local to my_function</span>
    <span class="code-builtin">print</span>(local_var)

<span class="code-function">my_function</span>()
<span class="code-comment"># print(local_var) # This would cause a NameError</span></code></pre>
        </li>
        <li>Global Scope: Variables defined outside of any function (at the top level of a script or
module) have global scope. They can be accessed from anywhere in the code, including
inside functions.​
<pre><code>global_var <span class="code-operator">=</span> <span class="code-number">50</span> <span class="code-comment"># global_var has global scope</span>

<span class="code-keyword">def</span> <span class="code-function">another_function</span>():
    <span class="code-builtin">print</span>(global_var) <span class="code-comment"># Accessing global_var</span>

<span class="code-function">another_function</span>()</code></pre>
            <p>If one needs to modify a global variable from inside a function, the <code>global</code> keyword must
be used to declare that intent. Otherwise, Python will create a new local variable with
the same name if an assignment is made.​</p>
<pre><code>count <span class="code-operator">=</span> <span class="code-number">0</span>
<span class="code-keyword">def</span> <span class="code-function">increment_global_count</span>():
    <span class="code-keyword">global</span> count <span class="code-comment"># Declare intent to modify the global variable</span>
    count <span class="code-operator">+=</span> <span class="code-number">1</span>
<span class="code-function">increment_global_count</span>()
<span class="code-builtin">print</span>(count) <span class="code-comment"># Output: 1</span></code></pre>
        </li>
        <li>Nonlocal Scope: This scope applies to nested functions. If an inner function needs to
modify a variable from an enclosing (but not global) function's scope, the <code>nonlocal</code>
keyword is used.​</li>
    </ul>
<pre><code></code></pre>
    <div class="page-break"></div>
<pre><code><span class="code-keyword">def</span> <span class="code-function">outer_function</span>():
    outer_var <span class="code-operator">=</span> <span class="code-string">"I am outer"</span>
    <span class="code-keyword">def</span> <span class="code-function">inner_function</span>():
        <span class="code-keyword">nonlocal</span> outer_var <span class="code-comment"># Declare outer_var as nonlocal</span>
        outer_var <span class="code-operator">=</span> <span class="code-string">"Modified by inner"</span>
        <span class="code-builtin">print</span>(f<span class="code-string">"Inner: {outer_var}"</span>)
    <span class="code-function">inner_function</span>()
    <span class="code-builtin">print</span>(f<span class="code-string">"Outer: {outer_var}"</span>)

<span class="code-function">outer_function</span>()
<span class="code-comment"># Output:</span>
<span class="code-comment"># Inner: Modified by inner</span>
<span class="code-comment"># Outer: Modified by inner</span></code></pre>
    <p>Python uses the LEGB rule (Local, Enclosing function locals, Global, Built-in) to resolve
variable names. It searches for a variable in this order of scopes. A clear understanding of
scope rules is essential for writing predictable code and avoiding common errors like
UnboundLocalError, which occurs when a local variable is referenced before it has been
assigned a value (often due to an attempt to modify a global or <code>nonlocal</code> variable without the
proper keyword).</p>

    <h3>3.5. Leveraging Python's Built-in Functions</h3>
    <p>Python comes with a rich set of built-in functions that are readily available without needing to
import any modules. These functions perform a wide variety of common tasks, making
programming more efficient.
Examples of commonly used built-in functions include:</p>
    <ul>
        <li><span class="code-builtin">print</span>(): Outputs data to the console.</li>
        <li><span class="code-builtin">input</span>(): Reads a line of text from user input.</li>
        <li><span class="code-builtin">len</span>(): Returns the length (number of items) of an object like a string, list, or tuple.</li>
        <li><span class="code-builtin">type</span>(): Returns the type of an object.</li>
        <li><span class="code-builtin">int</span>(), <span class="code-builtin">float</span>(), <span class="code-builtin">str</span>(), <span class="code-builtin">bool</span>(): Convert values to integer, float, string, or Boolean types,
respectively.</li>
        <li><span class="code-builtin">sum</span>(): Calculates the sum of items in an iterable (e.g., a list of numbers).</li>
        <li>max(), min(): Return the maximum or minimum item in an iterable or among several
arguments.</li>
        <li><span class="code-builtin">sorted</span>(): Returns a new sorted list from the items in an iterable.</li>
        <li><span class="code-builtin">range</span>(): Generates a sequence of numbers, often used in for loops.</li>
        <li><span class="code-builtin">enumerate</span>(): Returns an enumerate object, yielding pairs of index and value from an
iterable, useful in loops. A comprehensive list of built-in functions can be found in the
official Python documentation. Familiarity with these functions can save significant
time and effort.</li>
    </ul>
    <p>The learning focus for this module is on mastering the creation of reusable code blocks
through functions, understanding the mechanisms of data passage to and from these blocks,
and comprehending how variables are accessed and managed across different segments of a
program.</p>

    <h2>Module 4: Working with Collections – Python's Data
Structures</h2>
    <p>Python offers several built-in data structures, also known as collections, which are used to
store and organize multiple data items. Choosing the right data structure is crucial for writing
efficient and readable code, as each is optimized for different kinds of operations and use
cases. This module delves into lists, tuples, dictionaries, and sets. The selection of an
appropriate data structure can profoundly influence not only the performance of the code but
also its clarity and maintainability. For instance, using a list to store unique items where
frequent membership checks are needed is generally less efficient than employing a set,
which is specifically designed for such tasks.</p>

    <h3>4.1. Lists: Ordered, Mutable Sequences</h3>
    <p>Lists are one of the most versatile and commonly used data structures in Python.</p>
    <ul>
        <li>Definition: A list is an ordered collection of items that can be of different types. Lists
are mutable, meaning their contents (elements, size) can be changed after creation.
They also allow duplicate members.</li>
        <li>Syntax: Lists are created by placing comma-separated items inside square brackets ``.​
<pre><code>my_list <span class="code-operator">=</span> [<span class="code-number">1</span>, <span class="code-string">'hello'</span>, <span class="code-number">3.14</span>, <span class="code-builtin">True</span>]
empty_list <span class="code-operator">=</span> []</code></pre>
        </li>
        <li>Common Operations:
            <ul>
                <li>Accessing elements: Elements are accessed by their index, starting from 0.
Negative indexing can be used to access elements from the end (e.g., -1 for the
last item). my_list[1] would be "hello".</li>
                <li>Slicing: A portion of a list can be extracted using slicing my_list[start:end:step].
my_list[1:3] would be ['hello', 3.14].</li>
                <li>Adding elements:
                    <ul>
                        <li><code>append()</code>: Adds an item to the end of the list.</li>
                        <li><code>insert()</code>: Inserts an item at a specified position.</li>
                    </ul>
                </li>
                <li>Removing elements:
                    <ul>
                        <li><code>remove()</code>: Removes the first occurrence of a specified item.</li>
                        <li><code>pop()</code>: Removes and returns the item at a specified index (or the
last item if no index is given).</li>
                        <li><code>del</code> my_list[index]: Deletes an item at a specified index.</li>
                    </ul>
                </li>
                <li>Other operations:
                    <ul>
                        <li><code>len()</code>(my_list): Returns the number of items in the list.</li>
                        <li>item in my_list: Checks for membership (returns True or False).</li>
                        <li>Concatenation (+): Combines two lists.</li>
                        <li>Repetition (*): Repeats a list a certain number of times.</li>
                        <li><code>sort()</code>: Sorts the list in-place. <code>sorted()</code> returns a new sorted <code>list</code>.</li>
                        <li><code>reverse()</code>: Reverses the elements of the list in-place.</li>
                    </ul>
                </li>
                <li>List Comprehensions: A concise way to create lists. (Introduced here, detailed in
Module 9).​</li>
            </ul>
        </li>
    </ul>
<pre><code>squares <span class="code-operator">=</span> [x<span class="code-operator">**</span><span class="code-number">2</span> <span class="code-keyword">for</span> x <span class="code-keyword">in</span> <span class="code-builtin">range</span>(<span class="code-number">5</span>)] <span class="code-comment"># Results in [0, 1, 4, 9, 16]</span></code></pre>
    <h3>4.2. Tuples: Ordered, Immutable Sequences</h3>
    <p>Tuples are similar to lists but with a key difference: they are immutable.</p>
    <ul>
        <li>Definition: A tuple is an ordered collection of items that can be of different types.
Tuples are immutable, meaning once created, their contents cannot be changed. They
allow duplicate members.</li>
        <li>Syntax: Tuples are created by placing comma-separated items inside parentheses () or
just by separating items with commas (though parentheses are generally recommended
for clarity).​
<pre><code>my_tuple <span class="code-operator">=</span> (<span class="code-number">1</span>, <span class="code-string">"hello"</span>, <span class="code-number">3.14</span>, <span class="code-builtin">True</span>, <span class="code-string">"hello"</span>)
another_tuple <span class="code-operator">=</span> <span class="code-number">1</span>, <span class="code-number">2</span>, <span class="code-number">3</span> <span class="code-comment"># Parentheses are optional here</span>
empty_tuple <span class="code-operator">=</span> ()
single_item_tuple <span class="code-operator">=</span> (<span class="code-number">1</span>,) <span class="code-comment"># Note the trailing comma for a single-element tuple </span></code></pre>
        </li>
        <li>Common Operations:
            <ul>
                <li>Accessing elements: Similar to lists, using zero-based indexing.</li>
                <li>Slicing: Similar to lists.</li>
                <li>Other operations: <code>len()</code>(my_tuple), item <code>in</code> my_tuple, concatenation (<code>+</code>), repetition
(<code>*</code>).</li>
            </ul>
        </li>
        <li>Use Cases: Tuples are used when the data should remain constant throughout the
program. Examples include representing coordinates, RGB color values, or records from
a database. Their immutability makes them suitable as keys in dictionaries if all their
elements are also immutable. Immutability can also offer a degree of data integrity and,
in some contexts, slight performance advantages over lists.</li>
    </ul>

    <h3>4.3. Dictionaries: Unordered (Ordered in Python 3.7+) Key-Value Pairs</h3>
    <p>Dictionaries store data as collections of key-value pairs.</p>
    <ul>
        <li>Definition: A dictionary is a collection where each item is a pair consisting of a unique
key and its associated value. Keys must be of an immutable type (e.g., strings, numbers,
tuples containing only immutable elements). Values can be of any type and can be
duplicated. As of Python 3.7, dictionaries maintain insertion order; in earlier versions
(Python 3.6 and before), they were unordered. Dictionaries are mutable.</li>
        <li>Syntax: Dictionaries are created by placing comma-separated key: value pairs inside
curly braces {}.​
<pre><code>my_dict <span class="code-operator">=</span> {<span class="code-string">"name"</span>: <span class="code-string">"Alice"</span>, <span class="code-string">"age"</span>: <span class="code-number">30</span>, <span class="code-string">"city"</span>: <span class="code-string">"New York"</span>}
empty_dict <span class="code-operator">=</span> {}</code></pre>
        </li>
        <li>Common Operations:
            <ul>
                <li>Accessing values: Values are accessed using their corresponding key in square
brackets my_dict[key]. Accessing a non-existent key raises a KeyError. The
<code>get()</code> method can be used to access a value without raising an
error if the key is not found.</li>
                <li>Adding/Updating pairs: my_dict[new_key] = new_value adds a new pair or
updates the value if the key already exists. The <code>update()</code> method can
merge another dictionary.</li>
                <li>Removing items:
                    <ul>
                        <li><code>pop()</code>: Removes the item with the specified key and returns its value.</li>
                        <li><code>popitem()</code>: Removes and returns an arbitrary (key, value) pair (LIFO in
Python 3.7+).</li>
                        <li><code>del</code> my_dict[key]: Deletes the item with the specified key.</li>
                        <li><code>clear()</code>: Removes all items from the dictionary.</li>
                    </ul>
                </li>
                <li>Checking for key existence: key <code>in</code> my_dict.</li>
                <li>Getting views:
                    <ul>
                        <li><code>keys()</code>: Returns a view object displaying a list of all keys.</li>
                        <li><code>values()</code>: Returns a view object displaying a list of all values.</li>
                        <li><code>items()</code>: Returns a view object displaying a list of all key-value tuple pairs.</li>
                    </ul>
                </li>
                <li><code>len()</code>(my_dict): Returns the number of key-value pairs.</li>
            </ul>
        </li>
        <li>Use Cases: Ideal for storing structured data where items can be quickly looked up by a
unique identifier (the key), such as representing JSON objects, configuration settings,
or mapping relationships.</li>
    </ul>

    <h3>4.4. Sets: Unordered Collections of Unique Items</h3>
    <p>Sets are collections that store unordered items, and each item must be unique.</p>
    <ul>
        <li>Definition: A set is an unordered collection of unique, immutable items. Sets
themselves are mutable (items can be added or removed). Duplicate items are
automatically discarded.</li>
        <li>Syntax: Sets are created by placing comma-separated items inside curly braces {}. To
create an empty set, one must use the <span class="code-builtin">set</span>() constructor, as {} creates an empty
dictionary.​
<pre><code>my_set <span class="code-operator">=</span> {<span class="code-number">1</span>, <span class="code-number">2</span>, <span class="code-number">3</span>, <span class="code-string">"apple"</span>, <span class="code-number">2</span>} <span class="code-comment"># my_set will be {1, 2, 3, "apple"}</span>
empty_set <span class="code-operator">=</span> <span class="code-builtin">set</span>()</code></pre>
        </li>
        <li>Common Operations:
            <ul>
                <li>Adding elements: <code>add()</code>.</li>
                <li>Removing elements:
                    <ul>
                        <li><code>remove()</code>: Removes the specified item. Raises a KeyError if the item is
not found.</li>
                        <li><code>discard()</code>: Removes the specified item if it is present; does not raise an
error if not found.</li>
                        <li><code>pop()</code>: Removes and returns an arbitrary item from the set.</li>
                    </ul>
                </li>
                <li>Set operations:
                    <ul>
                        <li>Union (| or <code>union()</code>): Returns a new set containing all items from both sets.</li>
                        <li>Intersection (&amp; or <code>intersection()</code>): Returns a new set containing only items
common to both sets.</li>
                        <li>Difference (- or <code>difference()</code>): Returns a new set with items from the first set
that are not in the second.</li>
                        <li>Symmetric difference (^ or <code>symmetric_difference()</code>): Returns a new set with
items in either set, but not in both.</li>
                    </ul>
                </li>
                <li>item <code>in</code> my_set: Checks for membership.</li>
                <li><code>len()</code>(my_set): Returns the number of items.</li>
            </ul>
        </li>
        <li>Use Cases: Efficient for membership testing (checking if an item exists in a collection),
removing duplicate items from a sequence, and performing mathematical set
operations like union, intersection, etc..</li>
        <li><code>frozenset</code>: Python also provides <code>frozenset</code>, which is an immutable version of a set. Once
created, its contents cannot be changed. Because they are immutable and hashable,
frozensets can be used as dictionary keys or as elements of other sets.</li>
    </ul>
The critical distinction between mutable (<code>lists</code>, <code>dictionaries</code>, <code>sets</code>) and immutable (<code>tuples</code>,
<code>frozenset</code>) data structures has significant implications. Mutability affects how these
structures can be used (e.g., only immutable types can serve as dictionary keys ) and their
behavior when passed to functions or assigned to new variables (leading to aliasing where
multiple variables reference the same object, versus creating a new copy). Understanding this
distinction is vital for preventing errors and designing robust programs, as modifications to a
mutable object through one reference will be visible through all other references to that same
object.
Python's data structures are notably high-level and feature-rich, abstracting away many of
the low-level implementation details that programmers in other languages might have to
manage. They come equipped with a comprehensive suite of built-in methods and
functionalities, allowing developers to accomplish complex tasks with concise code. This
focus on high-level abstractions contributes significantly to Python's reputation for
productivity, enabling developers to concentrate on solving the problem at hand rather than
on the intricacies of data structure implementation.
The following table summarizes the key characteristics and common use cases for these
fundamental Python data structures:</p>
    <div class="page-break"></div>
    <table>
      <caption>Table 2: Python Data Structures: Key Characteristics and Use Cases</caption>
      <thead>
        <tr>
          <th>Data Structure</th>
          <th>Mutability</th>
          <th>Ordering</th>
          <th>Allows Duplicates?</th>
          <th>Indexing</th>
          <th>Key Use Cases</th>
          <th>Example Syntax</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>list</code></td>
          <td>Mutable</td>
          <td>Ordered (maintains insertion order)</td>
          <td>Yes</td>
          <td>Integer-based</td>
          <td>General-purpose sequences, storing collections of items, when order matters and items may change.</td>
          <td>my_list = [1, 'a', 2.0]</td>
        </tr>
        <tr>
          <td><code>tuple</code></td>
          <td>Immutable</td>
          <td>Ordered (maintains insertion order)</td>
          <td>Yes</td>
          <td>Integer-based</td>
          <td>Storing fixed collections of items (e.g., coordinates, records), dictionary keys (if elements are immutable).</td>
          <td>my_tuple = (1, 'a', 2.0)</td>
        </tr>
        <tr>
          <td><code>dict</code></td>
          <td>Mutable</td>
          <td>Ordered (Python 3.7+), Unordered (&lt;3.7)</td>
          <td>Keys: No, Values: Yes</td>
          <td>Key-based</td>
          <td>Storing key-value pairs, mapping, fast lookups by key, representing structured data (e.g., JSON).</td>
          <td>my_dict = {'key1': 1, 'key2': 'a'}</td>
        </tr>
        <tr>
          <td><code>set</code></td>
          <td>Mutable</td>
          <td>Unordered</td>
          <td>No</td>
          <td>Not applicable</td>
          <td>Membership testing, removing duplicates, mathematical set operations (union, intersection).</td>
          <td>my_set = {1, 'a', 2.0}</td>
        </tr>
        <tr>
          <td><code>frozenset</code></td>
          <td>Immutable</td>
          <td>Unordered</td>
          <td>No</td>
          <td>Not applicable</td>
          <td>Like sets, but immutable; can be used as dictionary keys or elements of other sets.</td>
          <td>my_fset = frozenset({1, 'a'})</td>
        </tr>
      </tbody>
    </table>
    <p>Data Sources:
The learning focus for this module is to understand how to select and effectively utilize the
appropriate data structure based on the specific requirements of the data and the operations
to be performed. This involves a clear comprehension of their distinct characteristics
regarding ordering, mutability, and uniqueness, as well as their common methods and
applications.</p>

    <h2>Module 5: Object-Oriented Programming (OOP) in
Python</h2>
    <p>Object-Oriented Programming (OOP) is a programming paradigm that uses "objects" – data
structures consisting of data fields and methods together with their interactions – to design
applications and computer programs. This module introduces the core concepts of OOP in
Python, including classes, objects, inheritance, polymorphism, and encapsulation. Adopting
OOP principles often involves a shift in thinking from procedural programming to modeling
problems in terms of interacting objects, their states, and behaviors, representing a higher
level of abstraction in software design.</p>

    <h3>5.1. Core OOP Concepts: An Overview</h3>
    <p>OOP revolves around the concept of objects, which can be thought of as instances of <code>class</code>es.
These objects encapsulate both data (attributes) and functions that operate on the data
(methods). The main pillars of OOP are:</p>
    <ul>
        <li>Encapsulation: This refers to the bundling of data (attributes) and the methods that
operate on that data into a single unit, known as a <code>class</code>. It also involves restricting
direct access to some of an object's components, which is a key aspect of data hiding.</li>
        <li>Inheritance: This mechanism allows a new <code>class</code> (subclass or child <code>class</code>) to acquire the
properties and methods of an existing <code>class</code> (superclass or parent <code>class</code>). Inheritance
promotes code reusability and establishes a hierarchical relationship between <code>class</code>es.</li>
        <li>Polymorphism: Literally meaning "many forms," polymorphism allows objects of
different <code>class</code>es to be treated as objects of a common super<code>class</code> or to respond to the
same method call in a way that is specific to their type. This enables flexibility and
dynamic behavior in programs.</li>
        <li>Abstraction: This involves hiding the complex implementation details of a system and
exposing only the essential features or functionalities to the user. Abstraction helps in
managing complexity by providing a simplified interface.</li>
    </ul>
    <p>The benefits of using OOP include improved code reusability (through inheritance), enhanced
modularity (as objects are self-contained), easier maintenance, and a more intuitive way to
model complex real-world systems.</p>

    <h3>5.2. Defining Classes and Creating Objects (Instances)</h3>
    <p>A <code>class</code> serves as a blueprint or template for creating objects. It defines a set of attributes
that characterize any object of the <code>class</code> and methods that operate on those attributes.</p>
    <ul>
        <li>Defining a Class: In Python, a <code>class</code> is defined using the <code>class</code> keyword, followed by the
class name (conventionally in CapitalizedWords or PascalCase) and a colon. The body
of the <code>class</code> is indented.​
<pre><code><span class="code-keyword">class</span> <span class="code-class">Dog</span>:
    <span class="code-keyword">pass</span> <span class="code-comment"># An empty class</span></code></pre>
        </li>
        <li>The <code>__init__()</code> Method: This special method, often called the constructor, is
automatically invoked when a new object (instance) of the <code>class</code> is created. Its primary
role is to initialize the instance's attributes. The first parameter of <code>__init__()</code> (and any
instance method) is conventionally named <code>self</code>, which refers to the instance being
created or acted upon.​
<pre><code><span class="code-keyword">class</span> <span class="code-class">Dog</span>:
    <span class="code-keyword">def</span> <span class="code-function">__init__</span>(<span class="code-builtin">self</span>, name, age): <span class="code-comment"># Constructor</span>
        <span class="code-builtin">self</span>.name <span class="code-operator">=</span> name <span class="code-comment"># Instance attribute</span>
        <span class="code-builtin">self</span>.age <span class="code-operator">=</span> age <span class="code-comment"># Instance attribute</span></code></pre>
        </li>
        <li>Creating Objects (Instantiation): An object is created by calling the <code>class</code> name as if it
were a function, passing any arguments required by the <code>__init__</code> method.​</li>
    </ul>
<pre><code>my_dog <span class="code-operator">=</span> <span class="code-class">Dog</span>(<span class="code-string">"Buddy"</span>, <span class="code-number">3</span>) <span class="code-comment"># Creates an instance of the Dog class</span>
another_dog <span class="code-operator">=</span> <span class="code-class">Dog</span>(<span class="code-string">"Lucy"</span>, <span class="code-number">5</span>)</code></pre>
    <p>Here, my_dog and another_dog are distinct objects of the <code>Dog</code> class, each with its own
name and age.</p>

    <h3>5.3. Attributes (Class and Instance) and Methods (Instance, Class,
Static)</h3>
    <p>Attributes represent the data associated with a class or its instances, while methods define
their behavior.</p>
    <ul>
        <li>Instance Attributes: These are specific to each instance of a <code>class</code>. They are typically
defined within the <code>__init__()</code> method using <code>self.attribute_name = value</code>. Each object will
have its own copy of instance attributes.​
    <div class="page-break"></div>
<pre><code><span class="code-comment"># In the Dog class above, self.name and self.age are instance attributes.</span>
<span class="code-builtin">print</span>(my_dog.name) <span class="code-comment"># Output: Buddy</span></code></pre>
        </li>
        <li>Class Attributes: These are shared by all instances of the class. They are defined
directly within the class body, outside of any instance methods.​
<pre><code><span class="code-keyword">class</span> <span class="code-class">Dog</span>:
    species <span class="code-operator">=</span> <span class="code-string">"Canis familiaris"</span> <span class="code-comment"># Class attribute</span>

    <span class="code-keyword">def</span> <span class="code-function">__init__</span>(<span class="code-builtin">self</span>, name, age):
        <span class="code-builtin">self</span>.name <span class="code-operator">=</span> name
        <span class="code-builtin">self</span>.age <span class="code-operator">=</span> age

<span class="code-builtin">print</span>(my_dog.species) <span class="code-comment"># Output: Canis familiaris</span>
<span class="code-builtin">print</span>(<span class="code-class">Dog</span>.species) <span class="code-comment"># Output: Canis familiaris</span></code></pre>
        </li>
        <li>Instance Methods: These are functions defined inside a <code>class</code> that operate on an
instance of the <code>class</code>. The first parameter of an instance method is always <code>self</code>, which
provides access to the instance's attributes and other methods.​
<pre><code><span class="code-keyword">class</span> <span class="code-class">Dog</span>:
    <span class="code-comment">#... (species and __init__ as above)</span>
    <span class="code-keyword">def</span> <span class="code-function">description</span>(<span class="code-builtin">self</span>): <span class="code-comment"># Instance method</span>
        <span class="code-keyword">return</span> f<span class="code-string">"{self.name} is {self.age} years old."</span>

    <span class="code-keyword">def</span> <span class="code-function">speak</span>(<span class="code-builtin">self</span>, sound): <span class="code-comment"># Another instance method</span>
        <span class="code-keyword">return</span> f<span class="code-string">"{self.name} says {sound}."</span>

<span class="code-builtin">print</span>(my_dog.<span class="code-function">description</span>()) <span class="code-comment"># Output: Buddy is 3 years old.</span>
<span class="code-builtin">print</span>(my_dog.<span class="code-function">speak</span>(<span class="code-string">"Woof"</span>)) <span class="code-comment"># Output: Buddy says Woof.</span></code></pre>
        </li>
        <li>Class Methods: These methods are bound to the <code>class</code> rather than its instances. They
receive the <code>class</code> itself as the first argument (conventionally named <code>cls</code>). Class methods
are defined using the <code>@classmethod</code> decorator. They can modify <code>class</code> attributes or be
used as factory methods to create instances.​
<pre><code><span class="code-keyword">class</span> <span class="code-class">Car</span>:
    total_cars <span class="code-operator">=</span> <span class="code-number">0</span> <span class="code-comment"># Class attribute</span>
    <span class="code-keyword">def</span> <span class="code-function">__init__</span>(<span class="code-builtin">self</span>):
        <span class="code-class">Car</span>.total_cars <span class="code-operator">+=</span> <span class="code-number">1</span></code></pre>
    <div class="page-break"></div>
<pre><code>    @classmethod
    <span class="code-keyword">def</span> <span class="code-function">get_total_cars</span>(<span class="code-builtin">cls</span>):
        <span class="code-keyword">return</span> <span class="code-builtin">cls</span>.total_cars

car1 <span class="code-operator">=</span> <span class="code-class">Car</span>()
car2 <span class="code-operator">=</span> <span class="code-class">Car</span>()
<span class="code-builtin">print</span>(<span class="code-class">Car</span>.<span class="code-function">get_total_cars</span>()) <span class="code-comment"># Output: 2</span></code></pre>
        </li>
        <li>Static Methods: These methods are also bound to the <code>class</code> but do not receive an
implicit first argument (neither <code>self</code> nor <code>cls</code>). They are essentially regular functions that
belong to the <code>class</code>'s namespace, often used for utility functions that are related to the
<code>class</code> but do not depend on instance or <code>class</code> state. They are defined using the
<code>@staticmethod</code> decorator.​
<pre><code><span class="code-keyword">class</span> <span class="code-class">MathUtils</span>:
    @staticmethod
    <span class="code-keyword">def</span> <span class="code-function">add</span>(x, y):
        <span class="code-keyword">return</span> x <span class="code-operator">+</span> y

<span class="code-builtin">print</span>(<span class="code-class">MathUtils</span>.<span class="code-function">add</span>(<span class="code-number">5</span>, <span class="code-number">3</span>)) <span class="code-comment"># Output: 8</span></code></pre>
        </li>
    </ul>
    <p>Attributes and methods are accessed using dot notation (e.g., <code>object.attribute</code>,
<code>object.method()</code>).</p>

    <h3>5.4. Inheritance: Building Class Hierarchies</h3>
    <p>Inheritance allows a <code>class</code> (child or subclass) to inherit attributes and methods from another
<code>class</code> (parent or superclass). This promotes code reuse and the creation of specialized
classes.</p>
    <ul>
        <li>Syntax: <code>class</code> ChildClass(ParentClass):.​
<pre><code><span class="code-keyword">class</span> <span class="code-class">Animal</span>: <span class="code-comment"># Parent class</span>
    <span class="code-keyword">def</span> <span class="code-function">__init__</span>(<span class="code-builtin">self</span>, name):
        <span class="code-builtin">self</span>.name <span class="code-operator">=</span> name
    <span class="code-keyword">def</span> <span class="code-function">speak</span>(<span class="code-builtin">self</span>):
        <span class="code-keyword">raise</span> <span class="code-builtin">NotImplementedError</span>(<span class="code-string">"Subclass must implement abstract method"</span>)

<span class="code-keyword">class</span> <span class="code-class">Dog</span>(<span class="code-class">Animal</span>): <span class="code-comment"># Child class inheriting from Animal</span>
    <span class="code-keyword">def</span> <span class="code-function">speak</span>(<span class="code-builtin">self</span>): <span class="code-comment"># Method overriding</span>
        <span class="code-keyword">return</span> f<span class="code-string">"{self.name} says Woof!"</span>

<span class="code-keyword">class</span> <span class="code-class">Cat</span>(<span class="code-class">Animal</span>): <span class="code-comment"># Another child class</span>
    <span class="code-keyword">def</span> <span class="code-function">speak</span>(<span class="code-builtin">self</span>): <span class="code-comment"># Method overriding</span></code></pre>
    <div class="page-break"></div>
<pre><code>        <span class="code-keyword">return</span> f<span class="code-string">"{self.name} says Meow!"</span>

my_pet_dog <span class="code-operator">=</span> <span class="code-class">Dog</span>(<span class="code-string">"Rex"</span>)
<span class="code-builtin">print</span>(my_pet_dog.<span class="code-function">speak</span>()) <span class="code-comment"># Output: Rex says Woof!</span></code></pre>
        </li>
        <li>Method Overriding: A subclass can provide its own implementation of a method that is
already defined in its parent <code>class</code>. This allows the subclass to customize or extend the
behavior of the inherited method. In the example above, <code>Dog</code> and <code>Cat</code> override the
<code>speak()</code> method of <code>Animal</code>.</li>
        <li>The <code>super()</code> Function: This built-in function is used to call a method from the parent
<code>class</code>. It is particularly useful in the <code>__init__()</code> method of a subclass to initialize the parent
<code>class</code>'s attributes, or when overriding a method but still wanting to execute the parent's
version of that method.​
<pre><code><span class="code-keyword">class</span> <span class="code-class">Labrador</span>(<span class="code-class">Dog</span>):
    <span class="code-keyword">def</span> <span class="code-function">__init__</span>(<span class="code-builtin">self</span>, name, color):
        <span class="code-builtin">super</span>().<span class="code-function">__init__</span>(name) <span class="code-comment"># Calls Dog's __init__ (which calls Animal's __init__)</span>
        <span class="code-builtin">self</span>.color <span class="code-operator">=</span> color
    <span class="code-keyword">def</span> <span class="code-function">speak</span>(<span class="code-builtin">self</span>): <span class="code-comment"># Overriding Dog's speak</span>
        <span class="code-keyword">return</span> f<span class="code-string">"{self.name} (a {self.color} Labrador) gently barks."</span></code></pre>
    <p>The <code>super()</code> function is essential for effective inheritance, especially in complex
hierarchies or with multiple inheritance, as it correctly navigates the Method Resolution
Order (MRO) to find the appropriate parent method. While straightforward in single
inheritance, its behavior in multiple inheritance scenarios can be more nuanced and
requires an understanding of the MRO.</p>
        </li>
        <li>Types of Inheritance: Python supports various forms of inheritance:
            <ul>
                <li>Single Inheritance: A subclass inherits from only one superclass (e.g., <code>Dog</code> from
<code>Animal</code>).</li>
                <li>Multiple Inheritance: A subclass inherits from multiple superclasses (e.g., <code>class</code>
Bat(Mammal, FlyingCreature):). This requires careful management due to
potential complexities like the "diamond problem," which Python resolves using
the MRO.</li>
                <li>Other forms include Multilevel (e.g., A -&gt; B -&gt; C), Hierarchical (e.g., A -&gt; B, A -&gt; C),
and Hybrid (a combination). Inheritance models an "is-a" relationship (e.g., a
<code>Dog</code> is an <code>Animal</code>).</li>
            </ul>
        </li>
    </ul>

    <h3>5.5. Polymorphism: Enabling Flexibility</h3>
    <p>Polymorphism allows objects of different classes to be treated uniformly if they share a
common interface (e.g., method names). The same operation can behave differently
depending on the object it is applied to.</p>
    <ul>
        <li>Achieved through Method Overriding: As seen in the inheritance example, <span class="code-class">Dog</span> and
<span class="code-class">Cat</span> objects can both call speak(), but the output is specific to their class.​
<pre><code>animals <span class="code-operator">=</span> [<span class="code-class">Dog</span>(<span class="code-string">"Rex"</span>), <span class="code-class">Cat</span>(<span class="code-string">"Whiskers"</span>)]
<span class="code-keyword">for</span> animal <span class="code-keyword">in</span> animals:
    <span class="code-builtin">print</span>(animal.<span class="code-function">speak</span>()) <span class="code-comment"># Polymorphic call to speak()</span>
<span class="code-comment"># Output:</span>
<span class="code-comment"># Rex says Woof!</span>
<span class="code-comment"># Whiskers says Meow!</span></code></pre>
        </li>
        <li>Duck Typing: Python's approach to polymorphism is often described by "duck typing":
if an object walks like a duck and quacks like a duck, then it is treated as a duck. Python
focuses on whether an object supports the required methods and attributes, rather
than its explicit class type. This dynamic nature makes Python inherently flexible.​
<pre><code><span class="code-keyword">def</span> <span class="code-function">make_it_speak</span>(entity):
    <span class="code-builtin">print</span>(entity.<span class="code-function">speak</span>()) <span class="code-comment"># Assumes entity has a speak() method</span>

<span class="code-keyword">class</span> <span class="code-class">Person</span>:
    <span class="code-keyword">def</span> <span class="code-function">speak</span>(<span class="code-builtin">self</span>):
        <span class="code-keyword">return</span> <span class="code-string">"Hello!"</span>

<span class="code-function">make_it_speak</span>(<code>Dog</code>(<span class="code-string">"Fido"</span>)) <span class="code-comment"># Output: Fido says Woof!</span>
<span class="code-function">make_it_speak</span>(<code>Person</code>()) <span class="code-comment"># Output: Hello!</span></code></pre>
        </li>
        <li>Operator Overloading: This is a form of polymorphism where operators (like <span class="code-operator">+</span>, <span class="code-operator">*</span>, <span class="code-operator">==</span>)
can be defined to work with custom objects by implementing special "dunder" methods
(e.g., <code>__add__()</code>, <code>__mul__()</code>, <code>__eq__()</code>) in the <code>class</code>. For example, the <code>+</code> operator performs
addition for numbers but concatenation for strings and lists.</li>
    </ul>

    <h3>5.6. Encapsulation: Protecting Data (Public, Protected, Private
Members)</h3>
    <p>Encapsulation is the practice of bundling an object's data (attributes) with the methods that
operate on that data. It also involves restricting direct access to an object's internal state,
which helps prevent accidental modification and maintains data integrity.
Python does not have strict access modifiers like public, private, or protected keywords found
in languages like Java or C++. Instead, it relies on naming conventions:</p>
    <ul>
        <li>Public Members: Attributes and methods are public by default. They can be accessed
from anywhere, inside or outside the <code>class</code>.​
<pre><code><span class="code-keyword">class</span> <span class="code-class">MyData</span>:
    <span class="code-keyword">def</span> <span class="code-function">__init__</span>(<span class="code-builtin">self</span>, value):
        <span class="code-builtin">self</span>.public_value <span class="code-operator">=</span> value <span class="code-comment"># Public attribute</span></code></pre>
    <div class="page-break"></div>
        </li>
        <li>Protected Members: Conventionally, attributes and methods prefixed with a single
underscore (e.g., <code>_protected_member</code>) are treated as protected. This is a hint to
programmers that these members are intended for internal use by the <code>class</code> and its
subclasses, but Python does not enforce this restriction.​
<pre><code><span class="code-keyword">class</span> <span class="code-class">MyData</span>:
    <span class="code-keyword">def</span> <span class="code-function">__init__</span>(<span class="code-builtin">self</span>, value):
        <span class="code-builtin">self</span>._protected_value <span class="code-operator">=</span> value <span class="code-comment"># Protected attribute</span></code></pre>
        </li>
        <li>Private Members: Attributes and methods prefixed with a double underscore (e.g.,
<code>__private_member</code>) are subject to name mangling. Python renames such members to
<code>_ClassName__private_member</code>, making them harder (but not impossible) to access
directly from outside the <code>class</code>. This is the closest Python comes to private members.​
<pre><code><span class="code-keyword">class</span> <span class="code-class">MyData</span>:
    <span class="code-keyword">def</span> <span class="code-function">__init__</span>(<span class="code-builtin">self</span>, value):
        <span class="code-builtin">self</span>.__private_value <span class="code-operator">=</span> value <span class="code-comment"># Private attribute</span>

    <span class="code-keyword">def</span> <span class="code-function">get_private_value</span>(<span class="code-builtin">self</span>): <span class="code-comment"># Getter method</span>
        <span class="code-keyword">return</span> <span class="code-builtin">self</span>.__private_value

    <span class="code-keyword">def</span> <span class="code-function">set_private_value</span>(<span class="code-builtin">self</span>, new_value): <span class="code-comment"># Setter method</span>
        <span class="code-keyword">if</span> new_value <span class="code-operator">&gt;</span> <span class="code-number">0</span>: <span class="code-comment"># Example validation</span>
            <span class="code-builtin">self</span>.__private_value <span class="code-operator">=</span> new_value
        <span class="code-keyword">else</span>:
            <span class="code-builtin">print</span>(<span class="code-string">"Value must be positive."</span>)

data_obj <span class="code-operator">=</span> <code>MyData</code>(<span class="code-number">10</span>)
<span class="code-comment"># print(data_obj.__private_value) # This would cause an AttributeError</span>
<span class="code-builtin">print</span>(data_obj.<code>_MyData__private_value</code>) <span class="code-comment"># Access via mangled name (discouraged)</span>
<span class="code-builtin">print</span>(data_obj.<span class="code-function">get_private_value</span>()) <span class="code-comment"># Access via getter</span></code></pre>
    <p>Python's OOP implementation is pragmatic and flexible rather than dogmatic. While it
supports OOP principles, its dynamic typing and conventions for privacy (like name
mangling for "private" attributes) differ from stricter languages. This approach
prioritizes developer trust and practicality.</p>
        </li>
        <li>Getters and Setters: To control access to (especially "private") attributes, public
methods known as getters (to retrieve an attribute's value) and setters (to modify an
attribute's value, often with validation) can be implemented. Python also offers a more
"Pythonic" way to manage attribute access using the <code>property()</code> decorator, which allows
getter and setter methods to be called automatically when an attribute is accessed or
assigned.</li>
    </ul>
The learning focus for this module is to cultivate an understanding of how to model real-world
entities and concepts using classes and objects. This includes learning to establish
relationships between classes via inheritance, enabling adaptable behavior through
polymorphism, and safeguarding data integrity through encapsulation techniques.</p>

    <h2>Module 6: Structuring Larger Projects – Modules and
Packages</h2>
    <p>As software projects grow in size and complexity, organizing code into manageable units
becomes essential for maintainability, reusability, and collaboration. Python provides modules
and packages as mechanisms for structuring larger applications. Without such organizational
constructs, developing and maintaining large-scale Python applications would be significantly
more challenging, as all code would reside in a single, monolithic file, leading to naming
conflicts and difficulties in navigation and teamwork.</p>

    <h3>6.1. Using Modules to Organize and Reuse Code</h3>
    <p>A module in Python is essentially a file containing Python definitions and statements. The file
name is the module name with the suffix .py appended. Modules allow for the logical
organization of related code (functions, classes, variables) into separate files, which can then
be imported and used in other modules or scripts.</p>
    <p>Benefits of using modules:</p>
    <ul>
        <li>Code Organization: Groups related code, making it easier to understand and manage.</li>
        <li>Reusability: Functions and classes defined in a module can be reused across multiple
parts of an application or in different projects.</li>
        <li>Namespace Separation: Each module has its own private namespace, which helps
avoid naming conflicts between identifiers from different modules.</li>
    </ul>
    <p>Creating and Importing Modules:
Creating a module is as simple as saving Python code in a .py file. For example, a file named
mymath.py containing math-related functions is a module named mymath.
There are several ways to import modules or their components :</p>
    <ol>
        <li><span class="code-keyword">import</span> module_name: Imports the entire module. Members of the module are
accessed using dot notation (e.g., module_name.member).​
<pre><code><span class="code-comment"># main_script.py</span>
<span class="code-keyword">import</span> mymath
result <span class="code-operator">=</span> mymath.<span class="code-function">add</span>(<span class="code-number">5</span>, <span class="code-number">3</span>)
<span class="code-builtin">print</span>(result)</code></pre>
        </li>
        <li><span class="code-keyword">from</span> module_name <span class="code-keyword">import</span> member1, member2: Imports specific members
(functions, classes, variables) from a module directly into the current namespace. These
members can then be accessed without the module name prefix.​
    <div class="page-break"></div>
<pre><code><span class="code-comment"># main_script.py</span>
<span class="code-keyword">from</span> mymath <span class="code-keyword">import</span> add, subtract
sum_val <span class="code-operator">=</span> <span class="code-function">add</span>(<span class="code-number">10</span>, <span class="code-number">2</span>)
diff_val <span class="code-operator">=</span> <span class="code-function">subtract</span>(<span class="code-number">10</span>, <span class="code-number">2</span>)</code></pre>
        </li>
        <li><span class="code-keyword">from</span> module_name <span class="code-keyword">import</span> <span class="code-operator">*</span>: Imports all names defined in a module into the current
namespace. This practice is generally discouraged because it can lead to namespace
pollution and make it unclear where a particular name comes from, especially in larger
projects.</li>
        <li><span class="code-keyword">import</span> module_name <span class="code-keyword">as</span> alias: Imports a module and gives it an alias (a shorter or
more convenient name). This is useful for long module names or to avoid name
collisions.​
<pre><code><span class="code-comment"># main_script.py</span>
<span class="code-keyword">import</span> mycustommathematicslibrary <span class="code-keyword">as</span> mlib
product <span class="code-operator">=</span> mlib.<span class="code-function">multiply</span>(<span class="code-number">4</span>, <span class="code-number">5</span>)</code></pre>
        </li>
    </ol>
    <p>Python's flexible import system supports various programming styles and requirements,
allowing developers to choose an import method that balances clarity, conciseness, and
namespace management for their specific needs.
When a module is imported, Python first compiles it into bytecode and stores it in a .pyc file in
a __pycache__ subdirectory. This .pyc file is then loaded on subsequent imports if the source
.py file hasn't changed, speeding up module loading. Python searches for modules in a list
of directories specified by sys.path, which includes the directory of the input script,
directories listed in the PYTHONPATH environment variable, and installation-dependent
default paths.
A common pattern in modules is the if __name__ == "__main__": block. Code within this block
will only execute when the module is run as a standalone script, not when it is imported by
another module. This allows a module to provide library functions when imported and also
have a script execution mode for testing or other purposes.</p>

    <h3>6.2. Creating and Importing Packages for Larger Applications</h3>
    <p>A package is a way of structuring Python's module namespace by using "dotted module
names". A package is a collection of related modules (and potentially sub-packages)
organized in a directory hierarchy.</p>
    <p>Structure of a Package:
A directory is treated as a Python package if it contains a special file named __init__.py. This
file can be empty, but it is required to mark the directory as a package. It can also contain
initialization code for the package or specify which modules should be exported when the
package is imported with from package import * (by defining an __all__ list).</p>
    <p>Example package structure:</p>
    <div class="page-break"></div>
<pre><code>my_project/
    main_app.py
    my_package/
        __init__.py
        module1.py
        module2.py
        sub_package/
            __init__.py
            module3.py</code></pre>
    <p>Here, my_package is a package, and sub_package is a sub-package within my_package.</p>
    <p>Importing from Packages:
Modules within packages are imported using dot notation that reflects the directory structure
:</p>
    <ul>
        <li><span class="code-keyword">import</span> my_package.module1</li>
        <li><span class="code-keyword">from</span> my_package.module1 <span class="code-keyword">import</span> specific_function</li>
        <li><span class="code-keyword">from</span> my_package <span class="code-keyword">import</span> module2 <span class="code-keyword">as</span> m2</li>
        <li><span class="code-keyword">from</span> my_package.sub_package <span class="code-keyword">import</span> module3</li>
    </ul>
    <p>The __init__.py file is more than just a marker; it can actively control the package's behavior
and API. For instance, it can execute package initialization code or make functions from its
sub-modules directly available at the package level, simplifying access for users of the
package. This capability allows package authors to design a clean and intuitive interface for
their package, abstracting the internal module organization.
The learning focus for this module is on acquiring the skills to structure Python code
effectively for larger projects. This involves making code more organized, maintainable, and
reusable by grouping related functionalities into modules and then further organizing these
modules into packages.</p>

    <h2>Module 7: Interacting with the System – File Handling</h2>
    <p>Programs often need to read data from files or write data to files for persistent storage.
Python provides comprehensive tools for file handling, allowing interaction with various file
types on the underlying file system. This module covers the essentials of reading from and
writing to both text and binary files, understanding file modes, and employing best practices
for resource management.</p>

    <h3>7.1. Reading From and Writing To Files (Text and Binary)</h3>
    <p>The core of file handling in Python is the built-in open() function, which is used to open a file
and return a file object. This object provides methods for reading from or writing to the file.
The open() function typically takes two main arguments: the file path (a string representing
the name and location of the file) and the mode (a string indicating how the file should be
opened).</p>
    <p>Text Files:
Text files store human-readable characters. Python handles encoding and decoding of text
automatically (usually defaulting to UTF-8).</p>
    <ul>
        <li>Reading from Text Files:
            <ul>
                <li>file.read(size<span class="code-operator">=</span><span class="code-operator">-</span><span class="code-number">1</span>): Reads up to size bytes from the file (or the entire file if size is
not specified or is negative) and returns it <span class="code-keyword">as</span> a string.</li>
                <li>file.readline(size<span class="code-operator">=</span><span class="code-operator">-</span><span class="code-number">1</span>): Reads a single line from the file (up to a newline character \n
or EOF) and returns it <span class="code-keyword">as</span> a string. If size is specified, it reads at most size bytes.</li>
                <li>file.readlines(hint<span class="code-operator">=</span><span class="code-operator">-</span><span class="code-number">1</span>): Reads all lines from the file and returns them <span class="code-keyword">as</span> a <span class="code-builtin">list</span> of
strings. Each string <span class="code-keyword">in</span> the <span class="code-builtin">list</span> corresponds to a line <span class="code-keyword">in</span> the file.</li>
            </ul>
<pre><code><span class="code-comment"># Reading an entire text file</span>
<span class="code-keyword">with</span> <span class="code-builtin">open</span>(<span class="code-string">'example.txt'</span>, <span class="code-string">'r'</span>) <span class="code-keyword">as</span> f:
    content <span class="code-operator">=</span> f.read()
    <span class="code-builtin">print</span>(content)

<span class="code-comment"># Reading a text file line by line</span>
<span class="code-keyword">with</span> <span class="code-builtin">open</span>(<span class="code-string">'example.txt'</span>, <span class="code-string">'r'</span>) <span class="code-keyword">as</span> f:
    <span class="code-keyword">for</span> line <span class="code-keyword">in</span> f: <span class="code-comment"># File objects are iterable</span>
        <span class="code-builtin">print</span>(line, end<span class="code-operator">=</span><span class="code-string">''</span>)</code></pre>
        </li>
        <li>Writing to Text Files:
            <ul>
                <li>file.write(string): Writes the given string to the file. It returns the number of
characters written.</li>
                <li>file.writelines(<span class="code-builtin">list</span>_of_strings): Writes a <span class="code-builtin">list</span> of strings to the file. Newline characters
are <span class="code-keyword">not</span> automatically added between strings.</li>
            </ul>
<pre><code><span class="code-comment"># Writing to a text file</span>
<span class="code-keyword">with</span> <span class="code-builtin">open</span>(<span class="code-string">'output.txt'</span>, <span class="code-string">'w'</span>) <span class="code-keyword">as</span> f:
    f.write(<span class="code-string">"Hello, world!\n"</span>)
    f.write(<span class="code-string">"This is a new line."</span>)</code></pre>
        </li>
    </ul>
    <p>Binary Files:
Binary files store data as raw bytes, such as images, audio files, or executable programs.
When working with binary files, the mode must include 'b'.</p>
    <ul>
        <li>Reading from Binary Files: Similar methods (read(), readline(), readlines()) are used,
but they <span class="code-keyword">return</span> bytes objects instead of strings.</li>
        <li>Writing to Binary Files: write() is used, and it expects a bytes object <span class="code-keyword">as</span> an argument.​
<pre><code><span class="code-comment"># Writing to a binary file</span>
<span class="code-keyword">with</span> <span class="code-builtin">open</span>(<span class="code-string">'data.bin'</span>, <span class="code-string">'wb'</span>) <span class="code-keyword">as</span> f:
    byte_data <span class="code-operator">=</span> b<span class="code-string">'\x00\x01\x02\x03\x04'</span></code></pre>
    <div class="page-break"></div>
<pre><code>    f.write(byte_data)

<span class="code-comment"># Reading from a binary file</span>
<span class="code-keyword">with</span> <span class="code-builtin">open</span>(<span class="code-string">'data.bin'</span>, <span class="code-string">'rb'</span>) <span class="code-keyword">as</span> f:
    binary_content <span class="code-operator">=</span> f.read()
    <span class="code-builtin">print</span>(binary_content) <span class="code-comment"># Output: b'\x00\x01\x02\x03\x04'</span></code></pre>
        </li>
    </ul>
    <p>Distinguishing between text and binary modes is fundamental. Text mode involves
interpretations of line endings and character encodings (e.g., UTF-8, ASCII), which would
corrupt binary data if applied incorrectly. Using the correct mode ('b') is essential for handling
non-text data accurately.
Closing Files:
After performing operations on a file, it is crucial to close it using the file.close() method.
Closing a file flushes any unwritten information and releases the file resource back to the
operating system. Forgetting to close files can lead to data loss or corruption, and resource
leaks.</p>

    <h3>7.2. Understanding File Modes and Using with for Best Practices</h3>
    <p>The mode argument in the <span class="code-builtin">open</span>() function specifies the type of operations allowed on the
opened file. The choice of mode is critical <span class="code-keyword">as</span> it dictates how the file is treated (e.g., whether
existing content is overwritten or new data is appended).
The <span class="code-keyword">with</span> Statement:
The recommended way to handle files <span class="code-keyword">in</span> Python is using the <span class="code-keyword">with</span> statement (also known <span class="code-keyword">as</span> a
context manager). The <span class="code-keyword">with</span> statement ensures that the file is automatically closed when the
block of code inside the <span class="code-keyword">with</span> statement is exited, even <span class="code-keyword">if</span> errors or exceptions occur during
processing. This is a critical best practice <span class="code-keyword">for</span> resource management <span class="code-keyword">as</span> it prevents common
issues like unclosed files, which can lead to resource leaks or data corruption.</p>
<pre><code><span class="code-keyword">try</span>:
    <span class="code-keyword">with</span> <span class="code-builtin">open</span>(<span class="code-string">'mydata.txt'</span>, <span class="code-string">'r'</span>) <span class="code-keyword">as</span> file_object:
        data <span class="code-operator">=</span> file_object.read()
        <span class="code-comment"># Process data</span>
<span class="code-keyword">except</span> <span class="code-builtin">FileNotFoundError</span>:
    <span class="code-builtin">print</span>(<span class="code-string">"Error: The file was not found."</span>)
<span class="code-keyword">except</span> <span class="code-builtin">Exception</span> <span class="code-keyword">as</span> e:
    <span class="code-builtin">print</span>(f<span class="code-string">"An error occurred: {e}"</span>)
<span class="code-comment"># file_object is automatically closed here, even if an exception occurred.</span></code></pre>
    <div class="page-break"></div>
    <p>This approach is more robust and Pythonic than manually calling file.close() within <span class="code-keyword">try</span>...<span class="code-keyword">finally</span>
blocks, simplifying code and improving reliability.
The granular control offered by various file modes provides flexibility but also demands
careful understanding. For example, using mode 'w' (write) on an existing file will truncate it
(erase its contents) before writing, which might be unintended if the goal was to add data.
Mode 'a' (append) should be used in such cases. These subtle but important differences in
mode behavior are crucial for correct file manipulation and preventing data loss.
The following table details common file handling modes in Python:</p>
    <p>Table 3: Common Python File Handling Modes</p>
    <table>
      <caption>Table 3: Common Python File Handling Modes</caption>
      <thead>
        <tr>
          <th>Mode</th>
          <th>Description</th>
          <th>Behavior if File Exists</th>
          <th>Behavior if File Doesn't Exist</th>
          <th>Cursor Position</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>'r'</td>
          <td>Read (default)</td>
          <td>Opens for reading</td>
          <td>Raises FileNotFoundError</td>
          <td>Beginning</td>
        </tr>
        <tr>
          <td>'w'</td>
          <td>Write</td>
          <td>Truncates (empties) file</td>
          <td>Creates new file</td>
          <td>Beginning</td>
        </tr>
        <tr>
          <td>'a'</td>
          <td>Append</td>
          <td>Opens for appending</td>
          <td>Creates new file</td>
          <td>End</td>
        </tr>
        <tr>
          <td>'x'</td>
          <td>Exclusive creation</td>
          <td>Raises FileExistsError</td>
          <td>Creates new file</td>
          <td>Beginning</td>
        </tr>
        <tr>
          <td>'r+'</td>
          <td>Read and Write</td>
          <td>Opens for reading and writing</td>
          <td>Raises FileNotFoundError</td>
          <td>Beginning</td>
        </tr>
        <tr>
          <td>'w+'</td>
          <td>Write and Read</td>
          <td>Truncates (empties) file</td>
          <td>Creates new file</td>
          <td>Beginning</td>
        </tr>
        <tr>
          <td>'a+'</td>
          <td>Append and Read</td>
          <td>Opens for appending and reading</td>
          <td>Creates new file</td>
          <td>End (for writing)</td>
        </tr>
        <tr>
          <td>'rb'</td>
          <td>Read Binary (binary)</td>
          <td>Opens for reading (binary)</td>
          <td>Raises FileNotFoundError</td>
          <td>Beginning</td>
        </tr>
        <tr>
          <td>'wb'</td>
          <td>Write Binary (binary)</td>
          <td>Truncates file (binary)</td>
          <td>Creates new file (binary)</td>
          <td>Beginning</td>
        </tr>
        <tr>
          <td>'ab'</td>
          <td>Append Binary (binary)</td>
          <td>Opens for appending (binary)</td>
          <td>Creates new file (binary)</td>
          <td>End</td>
        </tr>
        <tr>
          <td>'xb'</td>
          <td>Exclusive creation Binary (binary)</td>
          <td>Raises FileExistsError</td>
          <td>Creates new file (binary)</td>
          <td>Beginning</td>
        </tr>
        <tr>
          <td>'rb+'</td>
          <td>Read and Write Binary (binary)</td>
          <td>Opens for reading/writing (binary)</td>
          <td>Raises FileNotFoundError</td>
          <td>Beginning</td>
        </tr>
        <tr>
          <td>'wb+'</td>
          <td>Write and Read Binary (binary)</td>
          <td>Truncates file (binary)</td>
          <td>Creates new file (binary)</td>
          <td>Beginning</td>
        </tr>
        <tr>
          <td>'ab+'</td>
          <td>Append and Read Binary (binary)</td>
          <td>Opens for appending/reading (binary)</td>
          <td>Creates new file (binary)</td>
          <td>End (for writing)</td>
        </tr>
      </tbody>
    </table>
    <div class="page-break"></div>
    <p>Data Sources:
The learning focus for this module is on mastering the techniques for data persistence
through file input/output operations and understanding the best practices for managing file
resources to ensure data integrity and program stability.</p>

    <h2>Module 8: Robust Coding – Error and Exception
Handling</h2>
    <p>Writing code that can gracefully handle unexpected situations and errors is crucial for
developing robust and reliable applications. Python uses an exception handling mechanism
involving try, except, else, and finally blocks to manage runtime errors. This proactive
approach to error management is essential for creating production-ready code that does not
crash unexpectedly and can provide informative feedback or take corrective actions when
problems arise.</p>

    <h3>8.1. Understanding Different Types of Errors and Exceptions</h3>
    <p>In Python, errors can be broadly categorized:</p>
    <ul>
        <li>Syntax Errors (Parsing Errors): These occur when the Python interpreter encounters
code that violates the language's grammatical rules. The program will not run until these
errors are fixed. Example: prit("Hello") (misspelled print).</li>
        <li>Exceptions (Runtime Errors): These errors occur during the execution of a program,
even if the syntax is correct. When an exception occurs, the normal flow of the program
is disrupted, and Python creates an exception object. If not handled, the program
terminates and prints a traceback message.</li>
    </ul>
    <p>Common built-in exceptions include :</p>
    <ul>
        <li>ZeroDivisionError: Raised when attempting to divide by zero.</li>
        <li>TypeError: Raised when an operation or function is applied to an object of an
inappropriate type.</li>
        <li>ValueError: Raised when a built-in operation or function receives an argument that has
the right type but an inappropriate value.</li>
        <li>IndexError: Raised when a sequence subscript is out of range.</li>
        <li>KeyError: Raised when a dictionary key is not found.</li>
        <li>FileNotFoundError: Raised when an attempt to open a file fails because the file does not
exist.</li>
        <li>IOError: Raised when an I/O operation (like reading or writing a file) fails for an
I/O-related reason.</li>
        <li>ImportError: Raised when an import statement fails to find the module definition.</li>
        <li>EOFError: Raised when the input() function hits an end-of-file condition without reading
any data.</li>
    </ul>
    <p>Traceback messages provide information about where the exception occurred and the
sequence of calls that led to it, which is invaluable for debugging.</p>
    <div class="page-break"></div>
    <h3>8.2. Handling Exceptions with try, except, else, and finally Blocks</h3>
    <p>Python's try-except mechanism allows for the handling of exceptions.</p>
    <ul>
        <li>The <span class="code-keyword">try</span> Block: The code that might potentially raise an exception is placed inside the
<span class="code-keyword">try</span> block.​
<pre><code><span class="code-keyword">try</span>:
    result <span class="code-operator">=</span> <span class="code-number">10</span> <span class="code-operator">/</span> <span class="code-number">0</span>
<span class="code-keyword">except</span> <span class="code-builtin">ZeroDivisionError</span>:
    <span class="code-builtin">print</span>(<span class="code-string">"Cannot divide by zero!"</span>)</code></pre>
        </li>
        <li>The <span class="code-keyword">except</span> Block: If an exception occurs within the <span class="code-keyword">try</span> block, Python looks for a
matching <span class="code-keyword">except</span> block to handle it. If a match is found, the code within that <span class="code-keyword">except</span>
block is executed.
            <ul>
                <li>Catching Specific Exceptions: It is best practice to catch specific exceptions
rather than using a generic <span class="code-keyword">except</span>: clause. This allows for tailored error handling
and prevents masking unexpected bugs.​
<pre><code><span class="code-keyword">try</span>:
    value <span class="code-operator">=</span> <span class="code-builtin">int</span>(<span class="code-builtin">input</span>(<span class="code-string">"Enter a number: "</span>))
<span class="code-keyword">except</span> <span class="code-builtin">ValueError</span>:
    <span class="code-builtin">print</span>(<span class="code-string">"Invalid input. Please enter a whole number."</span>)</code></pre>
                </li>
                <li>Catching Multiple Exceptions: One can catch multiple exceptions <span class="code-keyword">in</span> a single
<span class="code-keyword">except</span> block by providing a <span class="code-builtin">tuple</span> of exception types.​
<pre><code><span class="code-keyword">try</span>:
    <span class="code-comment"># Code that might raise ValueError or TypeError</span>
    <span class="code-keyword">pass</span>
<span class="code-keyword">except</span> (<span class="code-builtin">ValueError</span>, <span class="code-builtin">TypeError</span>) <span class="code-keyword">as</span> e:
    <span class="code-builtin">print</span>(f<span class="code-string">"A ValueError or TypeError occurred: {e}"</span>)</code></pre>
                </li>
                <li>Catching the Exception Object: The exception object itself can be caught using
<span class="code-keyword">as</span> e (or any other variable name), providing access to error details.​
<pre><code><span class="code-keyword">try</span>:
    <span class="code-comment"># Risky operation</span>
    x <span class="code-operator">=</span> some_list[<span class="code-number">100</span>] <span class="code-comment"># Assuming some_list is shorter</span>
<span class="code-keyword">except</span> <span class="code-builtin">IndexError</span> <span class="code-keyword">as</span> err_obj:
    <span class="code-builtin">print</span>(f<span class="code-string">"An IndexError occurred: {err_obj}"</span>)</code></pre>
                </li>
                <li>Generic <span class="code-keyword">except</span>:: A bare <span class="code-keyword">except</span>: clause will catch any exception. However, this
should be used sparingly, <span class="code-keyword">as</span> it can make debugging difficult by hiding all errors,
including those one might <span class="code-keyword">not</span> have anticipated.</li>
            </ul>
        </li>
        <li>The <span class="code-keyword">else</span> Block: An optional <span class="code-keyword">else</span> block can follow the <span class="code-keyword">except</span> block(s). The code <span class="code-keyword">in</span> the
<span class="code-keyword">else</span> block is executed only <span class="code-keyword">if</span> no exceptions were raised <span class="code-keyword">in</span> the <span class="code-keyword">try</span> block. This is useful
<span class="code-keyword">for</span> separating code that should run only upon successful execution of the <span class="code-keyword">try</span> block
<span class="code-keyword">from</span> the main <span class="code-keyword">try</span> logic.​
<pre><code><span class="code-keyword">try</span>:
    num <span class="code-operator">=</span> <span class="code-builtin">int</span>(<span class="code-builtin">input</span>(<span class="code-string">"Enter numerator: "</span>))
    den <span class="code-operator">=</span> <span class="code-builtin">int</span>(<span class="code-builtin">input</span>(<span class="code-string">"Enter denominator: "</span>))
    result <span class="code-operator">=</span> num <span class="code-operator">/</span> den
<span class="code-keyword">except</span> <span class="code-builtin">ValueError</span>:
    <span class="code-builtin">print</span>(<span class="code-string">"Please enter valid numbers."</span>)
<span class="code-keyword">except</span> <span class="code-builtin">ZeroDivisionError</span>:
    <span class="code-builtin">print</span>(<span class="code-string">"Denominator cannot be zero."</span>)
<span class="code-keyword">else</span>:
    <span class="code-builtin">print</span>(f<span class="code-string">"The result is {result}."</span>) <span class="code-comment"># Executes if no exceptions</span></code></pre>
        </li>
        <li>The <span class="code-keyword">finally</span> Block: An optional <span class="code-keyword">finally</span> block is always executed, regardless of whether an
exception occurred <span class="code-keyword">in</span> the <span class="code-keyword">try</span> block or <span class="code-keyword">if</span> it was handled by an <span class="code-keyword">except</span> block, or even <span class="code-keyword">if</span> an
<span class="code-keyword">else</span> block was executed. It is typically used <span class="code-keyword">for</span> cleanup actions, such <span class="code-keyword">as</span> closing files or
releasing resources, ensuring these actions are performed under all circumstances.​
<pre><code>file <span class="code-operator">=</span> <span class="code-builtin">None</span>
<span class="code-keyword">try</span>:
    file <span class="code-operator">=</span> <span class="code-builtin">open</span>(<span class="code-string">"data.txt"</span>, <span class="code-string">"r"</span>)
    <span class="code-comment"># Process file</span>
<span class="code-keyword">except</span> <span class="code-builtin">FileNotFoundError</span>:
    <span class="code-builtin">print</span>(<span class="code-string">"File not found."</span>)
<span class="code-keyword">finally</span>:
    <span class="code-keyword">if</span> file:
        file.close() <span class="code-comment"># Ensure file is closed</span>
    <span class="code-builtin">print</span>(<span class="code-string">"Exiting file operation attempt."</span>)</code></pre>
    <p>The <span class="code-keyword">else</span> and <span class="code-keyword">finally</span> clauses provide powerful and refined control flow <span class="code-keyword">for</span> complex scenarios.
The <span class="code-keyword">else</span> block is particularly useful <span class="code-keyword">for</span> code that must execute only <span class="code-keyword">if</span> the <span class="code-keyword">try</span> block completes
successfully, clearly separating it <span class="code-keyword">from</span> the primary logic within <span class="code-keyword">try</span>. The <span class="code-keyword">finally</span> block is
indispensable <span class="code-keyword">for</span> cleanup operations, guaranteeing their execution.</p>
        </li>
        <li>Raising Exceptions: The <span class="code-keyword">raise</span> keyword can be used to manually trigger an exception.
This is useful <span class="code-keyword">for</span> indicating error conditions <span class="code-keyword">in</span> one's own code.​
<pre><code><span class="code-keyword">def</span> <span class="code-function">check_age</span>(age):</code></pre>
    <div class="page-break"></div>
<pre><code>    <span class="code-keyword">if</span> age <span class="code-operator">&lt;</span> <span class="code-number">0</span>:
        <span class="code-keyword">raise</span> <span class="code-builtin">ValueError</span>(<span class="code-string">"Age cannot be negative."</span>)
    <span class="code-comment">#...</span></code></pre>
        </li>
        <li>Nested <span class="code-keyword">try</span>-<span class="code-keyword">except</span> Blocks: <span class="code-keyword">try</span>-<span class="code-keyword">except</span> blocks can be nested to handle exceptions at
different levels of code execution, allowing <span class="code-keyword">for</span> more precise error management based
on context.</li>
    </ul>
The learning focus for this module is on developing the skills to write resilient and robust
Python programs. This involves understanding how to anticipate potential errors, handle them
gracefully using Python's exception handling mechanisms to prevent program crashes, and
provide a better, more stable user experience.</p>

    <h2>Module 9: Pythonic Enhancements – Comprehensions
and Lambda Functions</h2>
    <p>Python offers several constructs that allow for more concise, readable, and "Pythonic" code.
This module focuses on two such features: list comprehensions (and by extension, dictionary
and set comprehensions) and lambda functions. These features often allow complex
operations, such as creating a new list by transforming and filtering another, to be expressed
in a single, more readable line of code compared to traditional loops or full function
definitions, embodying Python's emphasis on code clarity and conciseness.</p>

    <h3>9.1. List Comprehensions for Concise List Creation and Filtering</h3>
    <p>List comprehensions provide a compact and elegant way to create new lists based on existing
iterables (like lists, tuples, ranges, or strings). They often replace multi-line for loops that
involve appending elements to a list, resulting in code that is both shorter and, in many cases,
easier to understand.</p>
    <p>Syntax:
The basic syntax for a list comprehension is [expression for item in iterable if condition].</p>
    <ul>
        <li>expression: An operation performed on item. The result of this expression becomes an
element in the new list.</li>
        <li>item: A variable representing each element from the iterable.</li>
        <li>iterable: The source sequence or collection.</li>
        <li>if condition (optional): A filter that includes the item in the new list only if the condition
evaluates to True.</li>
    </ul>
    <p>Benefits:</p>
    <ul>
        <li>Conciseness and Readability: They reduce boilerplate code, making the intent
clearer.</li>
        <li>Efficiency: In many cases, list comprehensions can be more efficient than equivalent
for loop constructs because some operations can be optimized by the Python
interpreter.</li>
    </ul>
    <p>Examples:</p>
    <div class="page-break"></div>
    <ol>
        <li>Creating a list of squares:​
<pre><code><span class="code-comment"># Using a for loop</span>
squares_loop <span class="code-operator">=</span> []
<span class="code-keyword">for</span> x <span class="code-keyword">in</span> <span class="code-builtin">range</span>(<span class="code-number">10</span>):
    squares_loop.append(x<span class="code-operator">**</span><span class="code-number">2</span>)

<span class="code-comment"># Using list comprehension</span>
squares_comp <span class="code-operator">=</span> [x<span class="code-operator">**</span><span class="code-number">2</span> <span class="code-keyword">for</span> x <span class="code-keyword">in</span> <span class="code-builtin">range</span>(<span class="code-number">10</span>)]
<span class="code-comment"># Both result in: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span>
<span class="code-comment"># </span></code></pre>
        </li>
        <li>Filtering elements (e.g., getting even numbers from a list):​
<pre><code>numbers <span class="code-operator">=</span> [<span class="code-number">1</span>, <span class="code-number">2</span>, <span class="code-number">3</span>, <span class="code-number">4</span>, <span class="code-number">5</span>, <span class="code-number">6</span>]
even_numbers <span class="code-operator">=</span> [x <span class="code-keyword">for</span> x <span class="code-keyword">in</span> numbers <span class="code-keyword">if</span> x <span class="code-operator">%</span> <span class="code-number">2</span> <span class="code-operator">==</span> <span class="code-number">0</span>]
<span class="code-comment"># even_numbers will be: [2, 4, 6]</span>
<span class="code-comment"># </span></code></pre>
        </li>
        <li>Applying an expression to filtered elements:​
<pre><code>original_prices <span class="code-operator">=</span> [<span class="code-number">50</span>, <span class="code-number">120</span>, <span class="code-number">80</span>, <span class="code-number">200</span>, <span class="code-number">150</span>]
discounted_prices <span class="code-operator">=</span> [price <span class="code-operator">*</span> <span class="code-number">0.9</span> <span class="code-keyword">for</span> price <span class="code-keyword">in</span> original_prices <span class="code-keyword">if</span> price <span class="code-operator">&gt;</span> <span class="code-number">100</span>]
<span class="code-comment"># discounted_prices will be: [108.0, 180.0, 135.0] (10% discount on prices &gt; 100)</span></code></pre>
        </li>
        <li>Nested List Comprehensions: These can be used to work with lists of lists or other
nested iterables, for example, to flatten a list of lists.​
<pre><code>matrix <span class="code-operator">=</span> [[<span class="code-number">1</span>, <span class="code-number">2</span>, <span class="code-number">3</span>], [<span class="code-number">4</span>, <span class="code-number">5</span>, <span class="code-number">6</span>], [<span class="code-number">7</span>, <span class="code-number">8</span>, <span class="code-number">9</span>]]
flattened <span class="code-operator">=</span> [num <span class="code-keyword">for</span> row <span class="code-keyword">in</span> matrix <span class="code-keyword">for</span> num <span class="code-keyword">in</span> row]
<span class="code-comment"># flattened will be: [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></code></pre>
        </li>
    </ol>
    <p>While powerful, it is important to avoid overly complex or deeply nested list comprehensions,
as they can become difficult to read and understand, thereby negating their primary benefit
of clarity.</p>
    <p>Dictionary and Set Comprehensions:
Similar syntax can be used to create dictionaries and sets:</p>
    <ul>
        <li>Set Comprehension: new_set <span class="code-operator">=</span> {expression <span class="code-keyword">for</span> item <span class="code-keyword">in</span> iterable <span class="code-keyword">if</span> condition}​
<pre><code>unique_squares <span class="code-operator">=</span> {x<span class="code-operator">**</span><span class="code-number">2</span> <span class="code-keyword">for</span> x <span class="code-keyword">in</span> [<span class="code-operator">-</span><span class="code-number">1</span>, <span class="code-number">0</span>, <span class="code-number">1</span>, <span class="code-number">2</span>, <span class="code-operator">-</span><span class="code-number">2</span>, <span class="code-number">3</span>]} <span class="code-comment"># {0, 1, 4, 9}</span></code></pre>
        </li>
        <li>Dictionary Comprehension: new_dict <span class="code-operator">=</span> {key_expression: value_expression <span class="code-keyword">for</span> item <span class="code-keyword">in</span>
iterable <span class="code-keyword">if</span> condition}​
    <div class="page-break"></div>
<pre><code>squared_dict <span class="code-operator">=</span> {x: x<span class="code-operator">**</span><span class="code-number">2</span> <span class="code-keyword">for</span> x <span class="code-keyword">in</span> <span class="code-builtin">range</span>(<span class="code-number">5</span>)} <span class="code-comment"># {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}</span></code></pre>
        </li>
    </ul>
    <h3>9.2. Lambda Functions: Small, Anonymous Functions for Simple
Operations</h3>
    <p>Lambda functions, also known as anonymous functions, provide a way to create small,
single-expression functions without a formal def statement or a name.</p>
    <p>Syntax:
The basic syntax is lambda arguments: expression.</p>
    <ul>
        <li>lambda: The keyword that defines an anonymous function.</li>
        <li>arguments: A comma-separated list of arguments (similar to a regular function's
parameters).</li>
        <li>expression: A single expression that is evaluated and returned when the lambda
function is called. Lambda functions cannot contain multiple statements or complex
logic.</li>
    </ul>
    <p>Characteristics and Use Cases:</p>
    <ul>
        <li>Anonymous: They do not have a name, though they can be assigned to a variable.</li>
        <li>Single Expression: The body of a lambda function is limited to a single expression.</li>
        <li>Concise: Useful for short, throwaway functions where a full function definition would be
overly verbose.</li>
        <li>Higher-Order Functions: Lambda functions are commonly used as arguments to
higher-order functions (functions that take other functions as arguments), such as
sorted(), map(), and filter().2</li>
    </ul>
    <p>Examples:</p>
    <ol>
        <li>A simple <span class="code-keyword">lambda</span> function to add two numbers:​
<pre><code>add <span class="code-operator">=</span> <span class="code-keyword">lambda</span> x, y: x <span class="code-operator">+</span> y
<span class="code-builtin">print</span>(<span class="code-function">add</span>(<span class="code-number">5</span>, <span class="code-number">3</span>)) <span class="code-comment"># Output: 8</span>
<span class="code-comment"># </span></code></pre>
        </li>
        <li>Using <span class="code-keyword">lambda</span> with <span class="code-builtin">sorted</span>() to specify a custom sort key:​
<pre><code>points <span class="code-operator">=</span> [(<span class="code-number">1</span>, <span class="code-number">2</span>), (<span class="code-number">3</span>, <span class="code-number">1</span>), (<span class="code-number">5</span>, <span class="code-number">4</span>), (<span class="code-number">2</span>, <span class="code-number">0</span>)]
<span class="code-comment"># Sort points based on the second element of each tuple</span>
points_sorted_by_y <span class="code-operator">=</span> <span class="code-builtin">sorted</span>(points, key<span class="code-operator">=</span><span class="code-keyword">lambda</span> point: point[<span class="code-number">1</span>])
<span class="code-comment"># points_sorted_by_y will be: [(2, 0), (3, 1), (1, 2), (5, 4)]</span>
<span class="code-comment"># </span></code></pre>
        </li>
        <li>Using <span class="code-keyword">lambda</span> with <span class="code-builtin">filter</span>() to select elements from a list:​
<pre><code>numbers <span class="code-operator">=</span> [<span class="code-number">1</span>, <span class="code-number">2</span>, <span class="code-number">3</span>, <span class="code-number">4</span>, <span class="code-number">5</span>, <span class="code-number">6</span>]
even_numbers <span class="code-operator">=</span> <span class="code-builtin">list</span>(<span class="code-builtin">filter</span>(<span class="code-keyword">lambda</span> x: x <span class="code-operator">%</span> <span class="code-number">2</span> <span class="code-operator">==</span> <span class="code-number">0</span>, numbers))
<span class="code-comment"># even_numbers will be: [2, 4, 6]</span>
<span class="code-comment"># </span></code></pre>
        </li>
        <li>Using <span class="code-keyword">lambda</span> with <span class="code-builtin">map</span>() to apply a function to each item <span class="code-keyword">in</span> an iterable:​
<pre><code>numbers <span class="code-operator">=</span> [<span class="code-number">1</span>, <span class="code-number">2</span>, <span class="code-number">3</span>, <span class="code-number">4</span>, <span class="code-number">5</span>]
squared_numbers <span class="code-operator">=</span> <span class="code-builtin">list</span>(<span class="code-builtin">map</span>(<span class="code-keyword">lambda</span> x: x<span class="code-operator">**</span><span class="code-number">2</span>, numbers))
<span class="code-comment"># squared_numbers will be: [1, 4, 9, 16, 25]</span></code></pre>
        </li>
    </ol>
    <p>Lambda functions are best suited for simple, single-expression logic. For more complex
operations, a standard named function defined with def is generally preferred for better
readability and maintainability. Attempting to cram overly complex logic into a lambda
function can make the code difficult to understand, undermining Python's core principle of
readability.</p>
    <p>Combining Lambda Functions with List Comprehensions:
While list comprehensions often provide a more direct way to achieve what map() and filter()
with lambdas do, lambdas can sometimes be used within comprehensions, though this is less
common and should be approached with caution to maintain readability.
The learning focus for this module is on mastering these Pythonic features to write more
elegant, concise, and efficient code for common tasks involving list manipulation, filtering, and
the creation of simple, ad-hoc functions.</p>

    <h2>Module 10: Your Learning Journey Forward</h2>
    <p>Mastering Python, like any programming language, is an ongoing process that extends
beyond understanding its syntax and core features. This final module provides guidance on
reinforcing learned concepts through practice, exploring Python's vast ecosystem, and
engaging with the community to stay updated. The extensive availability of practice exercises
and the strong recommendation for consistent application of knowledge underscore that
proficiency in Python is primarily cultivated through active engagement and problem-solving,
rather than passive consumption of information.</p>

    <h3>10.1. The Importance of Practice: Exercises and Projects</h3>
    <p>Theoretical knowledge forms the foundation, but practical application solidifies
understanding and builds skill. Regularly working through coding exercises and undertaking
small projects is crucial for internalizing Python concepts.</p>
    <ul>
        <li>Sources for Exercises:
            <ul>
                <li>GeeksforGeeks: Offers a vast collection of Python exercises categorized by
topic, ranging from basic conditional statements and list manipulations to more
advanced topics like OOP, data structures, and algorithms. Solutions are often
provided, allowing for self-assessment.</li>
                <li>CodeChef: Provides an online platform with numerous Python coding problems
suitable for beginners to advanced programmers, often with a competitive
programming flavor.</li>
                <li>W3Schools: Features interactive quizzes and exercises that complement its
tutorials, offering a way to test understanding of basic concepts.</li>
                <li>Real Python: Includes quizzes and exercises integrated into its articles and
learning paths, reinforcing the material covered.</li>
                <li>Programiz: Offers quizzes and coding challenges within its tutorials.</li>
            </ul>
        </li>
        <li>Starting Projects:
            <ul>
                <li>Begin with small, manageable projects that apply the concepts learned in each
module. For example:
                    <ul>
                        <li>After Module 2 (Control Flow): A simple number guessing game or a basic
calculator.</li>
                        <li>After Module 4 (Data Structures): A to-do list application or a contact book.</li>
                        <li>After Module 5 (OOP): Modeling a simple system like a library or a bank
account.</li>
                        <li>After Module 7 (File Handling): A program to read data from a CSV file and
perform some analysis, or a simple note-taking application that saves to a
file.</li>
                    </ul>
                </li>
                <li>Gradually increase the complexity of projects as proficiency grows.</li>
            </ul>
        </li>
    </ul>
    <p>Consistent practice is non-negotiable for achieving mastery. The availability of structured
exercises with solutions facilitates a learning cycle of attempting, checking, and
understanding correct approaches, which is highly effective for skill development.</p>

    <h3>10.2. Exploring Further: Standard Library Highlights and Popular
Third-Party Libraries</h3>
    <p>Python's true power is significantly amplified by its extensive Standard Library and the vast
ecosystem of third-party packages. Once the core language is understood, exploring these
resources is the next logical step.</p>
    <ul>
        <li>Python Standard Library: Python comes with "batteries included," meaning its
standard library provides a rich set of modules for common tasks without needing
external installation. Key modules to explore include:
            <ul>
                <li>math: For mathematical functions (e.g., trigonometric, logarithmic).</li>
                <li>datetime: For working with dates and times.</li>
                <li>json: For encoding and decoding JSON data.</li>
                <li>os: For interacting with the operating system (e.g., file system navigation,
environment variables).</li>
                <li>random: For generating random numbers and sequences.</li>
                <li>collections: Provides specialized container datatypes like defaultdict, Counter,
deque.</li>
                <li>re: For working with regular expressions (pattern matching in strings).</li>
            </ul>
        </li>
        <li>Third-Party Libraries and PyPI: The Python Package Index (PyPI) hosts hundreds of
thousands of third-party packages developed by the community. These libraries cater
to virtually every programming need. Installation is typically managed using pip,
Python's package installer. Some popular libraries in various domains include:
            <ul>
                <li>Web Development: Django, Flask (frameworks for building web applications).</li>
                <li>Data Science, AI, and Machine Learning:
                    <ul>
                        <li>NumPy: For numerical computing, especially with arrays and matrices.</li>
                        <li>SciPy: For scientific and technical computing.</li>
                        <li>Pandas: For data manipulation and analysis (provides DataFrames).</li>
                        <li>Scikit-learn: For machine learning algorithms.</li>
                        <li>TensorFlow, Keras, PyTorch: For deep learning.</li>
                        <li>NLTK, spaCy: For Natural Language Processing (NLP).</li>
                    </ul>
                </li>
                <li>GUI Development: Tkinter (part of the standard library), PyQt5, Kivy, PySide.</li>
                <li>Web Scraping and Automation: Requests (for HTTP requests), BeautifulSoup
(for parsing HTML/XML), Selenium (for browser automation).</li>
                <li>Image Processing: Pillow (a fork of PIL), OpenCV.</li>
                <li>Game Development: Pygame.</li>
            </ul>
        </li>
    </ul>
    <p>The core Python language serves as a powerful platform, but its utility is immensely expanded
by this rich ecosystem of libraries. A developer proficient only in core Python would be
missing out on a vast array of pre-built, optimized functionalities that make Python
exceptionally productive across diverse fields.</p>

    <h3>10.3. Staying Updated: Community and Official Resources</h3>
    <p>The field of technology is constantly evolving, and Python is no exception. Staying updated
with new versions, libraries, and best practices is important for continued growth.</p>
    <ul>
        <li>Official Python Resources:
            <ul>
                <li>python.org: The official Python website is the primary source for Python
downloads, documentation (tutorials, library reference, language reference), news
about new releases, and information about the Python Software Foundation
(PSF).</li>
            </ul>
        </li>
        <li>Community Engagement:
            <ul>
                <li>Forums and Mailing Lists: Online communities like the Python Discuss forum
(discuss.python.org), Stack Overflow, Reddit (e.g., r/learnpython), and various
mailing lists provide platforms for asking questions, sharing knowledge, and
learning from others.</li>
                <li>Conferences and Meetups: Events like PyCon (Python Conference) and local
user group meetups offer opportunities for learning, networking, and discovering
new trends.</li>
            </ul>
        </li>
        <li>Online Learning Platforms and Blogs:
            <ul>
                <li>Websites like Real Python, GeeksforGeeks, Programiz, DataCamp, and W3Schools
provide a wealth of tutorials, articles, courses, and examples. Many of these
resources are frequently updated with new content.</li>
                <li>Following influential Python bloggers and developers on social media can also
provide valuable insights.</li>
            </ul>
        </li>
    </ul>
    <p>The vibrant Python community and the abundance of high-quality official and third-party
resources create a supportive and dynamic learning environment. Actively engaging with
these resources is key to overcoming challenges, deepening understanding, and staying
current in the ever-evolving landscape of Python development.</p>

    <h2>Conclusion and Recommendations</h2>
    <p>This comprehensive study plan has outlined a structured path for learning Python
programming, from its fundamental syntax and data types to advanced concepts like
object-oriented programming, file handling, and error management. The journey through
these modules is designed to build a robust understanding of Python's capabilities and its
idiomatic usage.</p>
    <p>Key takeaways for an effective learning experience include:</p>
    <ol>
        <li>Embrace Python's Simplicity: Leverage Python's readable syntax and dynamic nature
to quickly grasp core programming concepts without getting bogged down by excessive
boilerplate.</li>
        <li>Understand Data Structures Deeply: The choice of data structures (lists, tuples,
dictionaries, sets) significantly impacts code efficiency and clarity. Master their
characteristics and use cases.</li>
        <li>Practice Consistently: Theoretical knowledge must be reinforced with hands-on
coding. Utilize the numerous online platforms for exercises and embark on small
projects to apply learned concepts in practical scenarios.</li>
        <li>Adopt Pythonic Practices: Learn and use features like list comprehensions, lambda
functions, and the with statement for file handling, as they lead to more concise,
readable, and efficient code.</li>
        <li>Master OOP Principles: Understanding classes, objects, inheritance, polymorphism,
and encapsulation is crucial for building larger, more maintainable applications.</li>
        <li>Structure Code Effectively: Utilize modules and packages to organize larger projects,
promoting reusability and maintainability.</li>
        <li>Write Robust Code: Implement comprehensive error and exception handling to create
applications that are resilient to unexpected situations.</li>
        <li>Explore the Ecosystem: Beyond the core language, Python's strength lies in its vast
standard library and third-party packages. Gradually explore these resources to
enhance productivity and tackle specialized tasks.</li>
        <li>Engage with the Community: Stay updated by following official Python news,
participating in forums, and utilizing the wealth of online learning resources. The Python
community is a valuable asset for continuous learning and support.</li>
    </ol>
    <p>It is recommended to approach this study plan module by module, ensuring a solid
understanding of each topic before moving to the next. Interleave learning with practical
exercises and, as confidence grows, with small personal projects. The journey of learning
Python is iterative; revisiting concepts and continually applying them will lead to proficiency
and mastery. Python's design philosophy, rich ecosystem, and supportive community make it
an accessible and rewarding language to learn for programmers of all levels.</p>

    <h2>Referenzen</h2>
    <p>1.​ Welcome to Python.org, Zugriff am Juni 11, 2025, https://www.python.org/
2.​ Python Tutorial | Learn Python Programming Language ..., Zugriff am Juni 11, 2025,
https://www.geeksforgeeks.org/python-programming-language-tutorial/
3.​ Python Packages - GeeksforGeeks, Zugriff am Juni 11, 2025,
https://www.geeksforgeeks.org/python-packages/
4.​ Our Documentation | Python.org, Zugriff am Juni 11, 2025,
https://www.python.org/doc/
5.​ Python For Beginners | Python.org, Zugriff am Juni 11, 2025,
https://www.python.org/about/gettingstarted/
6.​ Real Python: Python Tutorials, Zugriff am Juni 11, 2025, https://realpython.com/
7.​ Python Data Types (With Examples) - Programiz, Zugriff am Juni 11, 2025,
https://www.programiz.com/python-programming/variables-datatypes
8.​ Python Data Types Explained: A Beginner's Guide - DataCamp, Zugriff am Juni 11,
2025, https://www.datacamp.com/blog/python-data-types
9.​ Python Operators (With Examples) - Programiz, Zugriff am Juni 11, 2025,
https://www.programiz.com/python-programming/operators
10.​Learn Python 3: Control Flow Cheatsheet | Codecademy, Zugriff am Juni 11, 2025,
https://www.codecademy.com/learn/learn-python-3/modules/learn-python3-con
trol-flow/cheatsheet
11.​ Python Control Flow - Python Cheatsheet, Zugriff am Juni 11, 2025,
https://www.pythoncheatsheet.org/cheatsheet/control-flow
12.​operator — Standard operators as functions — Python 3.13.4 documentation,
Zugriff am Juni 11, 2025, https://docs.python.org/3/library/operator.html
13.​6.2 Control flow - Introduction to Python Programming | OpenStax, Zugriff am
Juni 11, 2025,
https://openstax.org/books/introduction-python-programming/pages/6-2-control
-flow
14.​1.13 Conditional statements (if-elif-else) - Python for Basic Data ..., Zugriff am Juni
11, 2025, https://libguides.ntu.edu.sg/python/ifelifelse
15.​Loops - Learn Python - Free Interactive Python Tutorial, Zugriff am Juni 11, 2025,
https://www.learnpython.org/en/Loops
16.​Python while Loop (With Examples) - Programiz, Zugriff am Juni 11, 2025,
https://www.programiz.com/python-programming/while-loop
17.​How To Use Python Continue, Break and Pass Statements when ..., Zugriff am Juni
11, 2025,
https://www.digitalocean.com/community/tutorials/how-to-use-break-continue-a
nd-pass-statements-when-working-with-loops-in-python-3
18.​Pass vs. Continue in Python Explained | Built In, Zugriff am Juni 11, 2025,
https://builtin.com/software-engineering-perspectives/pass-vs-continue-python
19.​Python Functions: How to Call &amp; Write Functions | DataCamp, Zugriff am Juni 11,
2025, https://www.datacamp.com/tutorial/functions-python-tutorial
20.​Learn Functions in Python: Definition, Types, and Examples - Simplilearn.com,
Zugriff am Juni 11, 2025,
https://www.simplilearn.com/tutorials/python-tutorial/python-functions
21.​Defining Your Own Python Function, Zugriff am Juni 11, 2025,
https://realpython.com/defining-your-own-python-function/
22.​5 Types of Python Function Arguments | Built In, Zugriff am Juni 11, 2025,
https://builtin.com/software-engineering-perspectives/arguments-in-python
23.​A Comprehensive Guide to Python Function Arguments - Analytics Vidhya,
Zugriff am Juni 11, 2025,
https://www.analyticsvidhya.com/blog/2024/01/a-comprehensive-guide-to-pytho
n-function-arguments/
24.​Is python OOP the real thing ? : r/learnpython - Reddit, Zugriff am Juni 11, 2025,
https://www.reddit.com/r/learnpython/comments/1bcjmdl/is_python_oop_the_rea
l_thing/
25.​The Python return Statement: Usage and Best Practices – Real Python, Zugriff am
Juni 11, 2025, https://realpython.com/python-return-statement/
26.​mimo.org, Zugriff am Juni 11, 2025,
https://mimo.org/glossary/python/return#:~:text=Python%20functions%20can%2
0return%20multiple,then%20easily%20unpack%20these%20values.
27.​What are global, local, and nonlocal scopes in Python - Python ..., Zugriff am Juni
11, 2025, https://www.python-engineer.com/posts/global-local-nonlocal-python/
28.​Python Variables: Global, Local, and Nonlocal - Geekster, Zugriff am Juni 11, 2025,
https://www.geekster.in/articles/python-variables/
29.​Python's Built-in Functions: A Complete Exploration, Zugriff am Juni 11, 2025,
https://realpython.com/python-built-in-functions/
30.​Python Built-in Functions - Programiz, Zugriff am Juni 11, 2025,
https://www.programiz.com/python-programming/methods/built-in
31.​Python Data Structures: Lists, Dictionaries, Sets, Tuples – Dataquest, Zugriff am
Juni 11, 2025, https://www.dataquest.io/blog/data-structures-in-python/
32.​When should I use a list, dictionary, tuple, or set in Python? : r/learnpython -
Reddit, Zugriff am Juni 11, 2025,
https://www.reddit.com/r/learnpython/comments/1j4ia9n/when_should_i_use_a_li
st_dictionary_tuple_or_set/
33.​Lists, Tuples, Dictionaries, and Sets · HonKit - Computer Science Department,
Zugriff am Juni 11, 2025,
https://cs.du.edu/~intropython/byte-of-python/data_structures.html
34.​Difference Between Dictionary, List, Tuples and Sets | Scaler Topics, Zugriff am
Juni 11, 2025,
https://www.scaler.com/topics/python/difference-between-dictionary-list-tupleand-set-in-python/
35.​Common Python Data Structures (Guide) – Real Python, Zugriff am Juni 11, 2025,
https://realpython.com/python-data-structures/
36.​Object-Oriented Programming (OOP) in Python – Real Python, Zugriff am Juni 11,
2025, https://realpython.com/python3-object-oriented-programming/
37.​Python Classes: The Power of Object-Oriented Programming, Zugriff am Juni 11,
2025, https://realpython.com/python-classes/
38.​Python Concepts of Object-Oriented Programming, Zugriff am Juni 11, 2025,
https://bcrf.biochem.wisc.edu/2023/02/16/python-concepts-of-object-oriented-p
rogramming/
39.​Python Encapsulation (With Examples) - WsCube Tech, Zugriff am Juni 11, 2025,
https://www.wscubetech.com/resources/python/encapsulation
40.​Encapsulation in Python - GeeksforGeeks, Zugriff am Juni 11, 2025,
https://www.geeksforgeeks.org/encapsulation-in-python/
41.​Polymorphism and Inheritance in Python - AlmaBetter, Zugriff am Juni 11, 2025,
https://www.almabetter.com/bytes/tutorials/python/python-inheritance-and-poly
morphism
42.​Polymorphism in Python - GeeksforGeeks, Zugriff am Juni 11, 2025,
https://www.geeksforgeeks.org/polymorphism-in-python/
43.​Python Inheritance (With Examples) - Programiz, Zugriff am Juni 11, 2025,
https://www.programiz.com/python-programming/inheritance
44.​Polymorphism in Python(with Examples) - Programiz, Zugriff am Juni 11, 2025,
https://www.programiz.com/python-programming/polymorphism
45.​Classes and Objects I Tutorials &amp; Notes | Python - HackerEarth, Zugriff am Juni 11,
2025,
https://www.hackerearth.com/practice/python/object-oriented-programming/cla
sses-and-objects-i/tutorial/
46.​Object-Oriented Programming in Python (OOP): Tutorial | DataCamp, Zugriff am
Juni 11, 2025, https://www.datacamp.com/tutorial/python-oop-tutorial
47.​Object-Oriented Programming (OOP) (Learning Path) - Real Python, Zugriff am
Juni 11, 2025,
https://realpython.com/learning-paths/object-oriented-programming-oop-pytho
n/
48.​Modules and Packages - Learn Python - Free Interactive Python Tutorial, Zugriff
am Juni 11, 2025, https://www.learnpython.org/en/Modules_and_Packages
49.​File Handling in Python - GeeksforGeeks, Zugriff am Juni 11, 2025,
https://www.geeksforgeeks.org/file-handling-python/
50.​File Handling in Python: A Comprehensive Guide - PyQuant News, Zugriff am Juni
11, 2025,
https://www.pyquantnews.com/free-python-resources/file-handling-in-python-a
-comprehensive-guide
51.​Python Try Except - GeeksforGeeks, Zugriff am Juni 11, 2025,
https://www.geeksforgeeks.org/python-try-except/
52.​The ultimate guide to Python exception handling - Honeybadger Developer Blog,
Zugriff am Juni 11, 2025,
https://www.honeybadger.io/blog/a-guide-to-exception-handling-in-python/
53.​List Comprehension in Python {Benefits, Examples} - phoenixNAP, Zugriff am Juni
11, 2025, https://phoenixnap.com/kb/list-comprehension-python
54.​How to handle lambda in list comprehension - LabEx, Zugriff am Juni 11, 2025,
https://labex.io/tutorials/python-how-to-handle-lambda-in-list-comprehension-4
51189
55.​Python Exercise with Practice Questions and Solutions ..., Zugriff am Juni 11, 2025,
https://www.geeksforgeeks.org/python-exercises-practice-questions-and-soluti
ons/
56.​Python Coding Practice Online: 195+ Problems on CodeChef, Zugriff am Juni 11,
2025, https://www.codechef.com/practice/python
57.​Python Tutorial - W3Schools.am, Zugriff am Juni 11, 2025,
https://www.w3schools.am/python/default.html
58.​Python Looping Techniques - Programiz, Zugriff am Juni 11, 2025,
https://www.programiz.com/python-programming/looping-technique
59.​DSA: A Complete Roadmap Using Python - Programiz PRO, Zugriff am Juni 11,
2025, https://programiz.pro/learn/master-dsa-with-python
60.​How to write a loop with conditions - Python discussion forum, Zugriff am Juni 11,
2025, https://discuss.python.org/t/how-to-write-a-loop-with-conditions/13046</p>
    <div class="page-break"></div>
</body>
</html>
"""

# Regex to find <pre><code>...</code></pre> blocks.
# It captures the content within the <code> tags.
# Using re.DOTALL so that '.' matches newlines as well.
pattern = r"<pre><code>(.*?)</code></pre>"

# Perform the substitution
